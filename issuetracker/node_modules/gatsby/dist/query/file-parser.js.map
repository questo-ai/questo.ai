{"version":3,"sources":["../../src/query/file-parser.js"],"names":["fs","require","crypto","_","getGraphQLTag","report","apiRunnerNode","boundActionCreators","generateQueryName","def","hash","file","name","value","camelCase","kind","warnForUnknownQueryVariable","varName","usageFunction","warn","parseToAst","filePath","fileStr","ast","transpiled","filename","contents","length","item","tmp","error","queryExtractionGraphQLError","componentPath","undefined","queryExtractionBabelError","warnForGlobalTag","findGraphQLTags","text","Promise","resolve","reject","then","queries","documentLocations","WeakMap","extractStaticQuery","taggedTemplateExpressPath","isHook","gqlAst","isGlobal","definitions","forEach","set","node","start","loc","map","d","isStaticQuery","traverse","TemplateElement","templateElementPath","templateLoc","push","JSXElement","path","openingElement","JSXAttribute","jsxPath","TaggedTemplateExpression","templatePath","Identifier","identifierPath","found","VariableDeclarator","varPath","id","init","type","CallExpression","hookPath","callee","get","referencesImport","firstArg","isTaggedTemplateExpression","isIdentifier","ExportNamedDeclaration","state","innerPath","uniqueQueries","uniqBy","q","catch","cache","FileParser","parseFile","readFile","err","indexOf","createHash","update","digest","astDefinitions","queryExtractedBabelSuccess","parseFiles","files","documents","Map","all","doc"],"mappings":"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","sourcesContent":["// @flow\nconst fs = require(`fs-extra`)\nconst crypto = require(`crypto`)\nconst _ = require(`lodash`)\n\n// Traverse is a es6 module...\nimport traverse from \"@babel/traverse\"\nconst getGraphQLTag = require(`babel-plugin-remove-graphql-queries`)\n  .getGraphQLTag\nconst report = require(`gatsby-cli/lib/reporter`)\n\nimport type { DocumentNode, DefinitionNode } from \"graphql\"\nimport { babelParseToAst } from \"../utils/babel-parse-to-ast\"\n\nconst apiRunnerNode = require(`../utils/api-runner-node`)\nconst { boundActionCreators } = require(`../redux/actions`)\n\n/**\n * Add autogenerated query name if it wasn't defined by user.\n */\nconst generateQueryName = ({ def, hash, file }) => {\n  if (!def.name || !def.name.value) {\n    def.name = {\n      value: `${_.camelCase(file)}${hash}`,\n      kind: `Name`,\n    }\n  }\n  return def\n}\n\nconst warnForUnknownQueryVariable = (varName, file, usageFunction) =>\n  report.warn(\n    `\\nWe were unable to find the declaration of variable \"${varName}\", which you passed as the \"query\" prop into the ${usageFunction} declaration in \"${file}\".\n\nPerhaps the variable name has a typo?\n\nAlso note that we are currently unable to use queries defined in files other than the file where the ${usageFunction} is defined. If you're attempting to import the query, please move it into \"${file}\". If being able to import queries from another file is an important capability for you, we invite your help fixing it.\\n`\n  )\n\nasync function parseToAst(filePath, fileStr) {\n  let ast\n\n  // Preprocess and attempt to parse source; return an AST if we can, log an\n  // error if we can't.\n  const transpiled = await apiRunnerNode(`preprocessSource`, {\n    filename: filePath,\n    contents: fileStr,\n  })\n  if (transpiled && transpiled.length) {\n    for (const item of transpiled) {\n      try {\n        const tmp = babelParseToAst(item, filePath)\n        ast = tmp\n        break\n      } catch (error) {\n        report.error(error)\n        boundActionCreators.queryExtractionGraphQLError({\n          componentPath: filePath,\n        })\n        continue\n      }\n    }\n    if (ast === undefined) {\n      report.error(`Failed to parse preprocessed file ${filePath}`)\n      boundActionCreators.queryExtractionGraphQLError({\n        componentPath: filePath,\n      })\n\n      return null\n    }\n  } else {\n    try {\n      ast = babelParseToAst(fileStr, filePath)\n    } catch (error) {\n      boundActionCreators.queryExtractionBabelError({\n        componentPath: filePath,\n        error,\n      })\n      report.error(\n        `There was a problem parsing \"${filePath}\"; any GraphQL ` +\n          `fragments or queries in this file were not processed. \\n` +\n          `This may indicate a syntax error in the code, or it may be a file type ` +\n          `that Gatsby does not know how to parse.`\n      )\n\n      return null\n    }\n  }\n\n  return ast\n}\n\nconst warnForGlobalTag = file =>\n  report.warn(\n    `Using the global \\`graphql\\` tag is deprecated, and will not be supported in v3.\\n` +\n      `Import it instead like:  import { graphql } from 'gatsby' in file:\\n` +\n      file\n  )\n\nasync function findGraphQLTags(file, text): Promise<Array<DefinitionNode>> {\n  return new Promise((resolve, reject) => {\n    parseToAst(file, text)\n      .then(ast => {\n        let queries = []\n        if (!ast) {\n          resolve(queries)\n          return\n        }\n\n        /**\n         * A map of graphql documents to unique locations.\n         *\n         * A graphql document's unique location is made of:\n         *\n         *  - the location of the graphql template literal that contains the document, and\n         *  - the document's location within the graphql template literal\n         *\n         * This is used to prevent returning duplicated documents.\n         */\n        const documentLocations = new WeakMap()\n\n        const extractStaticQuery = (\n          taggedTemplateExpressPath,\n          isHook = false\n        ) => {\n          const { ast: gqlAst, text, hash, isGlobal } = getGraphQLTag(\n            taggedTemplateExpressPath\n          )\n          if (!gqlAst) return\n\n          if (isGlobal) warnForGlobalTag(file)\n\n          gqlAst.definitions.forEach(def => {\n            documentLocations.set(\n              def,\n              `${taggedTemplateExpressPath.node.start}-${def.loc.start}`\n            )\n            generateQueryName({\n              def,\n              hash,\n              file,\n            })\n          })\n\n          const definitions = [...gqlAst.definitions].map(d => {\n            d.isStaticQuery = true\n            d.isHook = isHook\n            d.text = text\n            d.hash = hash\n\n            taggedTemplateExpressPath.traverse({\n              TemplateElement(templateElementPath) {\n                d.templateLoc = templateElementPath.node.loc\n              },\n            })\n\n            return d\n          })\n\n          queries.push(...definitions)\n        }\n\n        // Look for queries in <StaticQuery /> elements.\n        traverse(ast, {\n          JSXElement(path) {\n            if (path.node.openingElement.name.name !== `StaticQuery`) {\n              return\n            }\n\n            // astexplorer.com link I (@kyleamathews) used when prototyping this algorithm\n            // https://astexplorer.net/#/gist/ab5d71c0f08f287fbb840bf1dd8b85ff/2f188345d8e5a4152fe7c96f0d52dbcc6e9da466\n            path.traverse({\n              JSXAttribute(jsxPath) {\n                if (jsxPath.node.name.name !== `query`) {\n                  return\n                }\n                jsxPath.traverse({\n                  // Assume the query is inline in the component and extract that.\n                  TaggedTemplateExpression(templatePath) {\n                    extractStaticQuery(templatePath)\n                  },\n                  // Also see if it's a variable that's passed in as a prop\n                  // and if it is, go find it.\n                  Identifier(identifierPath) {\n                    if (identifierPath.node.name !== `graphql`) {\n                      const varName = identifierPath.node.name\n                      let found = false\n                      traverse(ast, {\n                        VariableDeclarator(varPath) {\n                          if (\n                            varPath.node.id.name === varName &&\n                            varPath.node.init.type ===\n                              `TaggedTemplateExpression`\n                          ) {\n                            varPath.traverse({\n                              TaggedTemplateExpression(templatePath) {\n                                found = true\n                                extractStaticQuery(templatePath)\n                              },\n                            })\n                          }\n                        },\n                      })\n                      if (!found) {\n                        warnForUnknownQueryVariable(\n                          varName,\n                          file,\n                          `<StaticQuery>`\n                        )\n                      }\n                    }\n                  },\n                })\n              },\n            })\n            return\n          },\n        })\n\n        // Look for queries in useStaticQuery hooks.\n        traverse(ast, {\n          CallExpression(hookPath) {\n            if (\n              hookPath.node.callee.name !== `useStaticQuery` ||\n              !hookPath.get(`callee`).referencesImport(`gatsby`)\n            ) {\n              return\n            }\n\n            const firstArg = hookPath.get(`arguments`)[0]\n\n            // Assume the query is inline in the component and extract that.\n            if (firstArg.isTaggedTemplateExpression()) {\n              extractStaticQuery(firstArg, true)\n              // Also see if it's a variable that's passed in as a prop\n              // and if it is, go find it.\n            } else if (firstArg.isIdentifier()) {\n              if (\n                firstArg.node.name !== `graphql` &&\n                firstArg.node.name !== `useStaticQuery`\n              ) {\n                const varName = firstArg.node.name\n                let found = false\n                traverse(ast, {\n                  VariableDeclarator(varPath) {\n                    if (\n                      varPath.node.id.name === varName &&\n                      varPath.node.init.type === `TaggedTemplateExpression`\n                    ) {\n                      varPath.traverse({\n                        TaggedTemplateExpression(templatePath) {\n                          found = true\n                          extractStaticQuery(templatePath, true)\n                        },\n                      })\n                    }\n                  },\n                })\n                if (!found) {\n                  warnForUnknownQueryVariable(varName, file, `useStaticQuery`)\n                }\n              }\n            }\n          },\n        })\n\n        // Look for exported page queries\n        traverse(ast, {\n          ExportNamedDeclaration(path, state) {\n            path.traverse({\n              TaggedTemplateExpression(innerPath) {\n                const { ast: gqlAst, isGlobal, hash, text } = getGraphQLTag(\n                  innerPath\n                )\n                if (!gqlAst) return\n\n                if (isGlobal) warnForGlobalTag(file)\n\n                gqlAst.definitions.forEach(def => {\n                  documentLocations.set(\n                    def,\n                    `${innerPath.node.start}-${def.loc.start}`\n                  )\n                  generateQueryName({\n                    def,\n                    hash,\n                    file,\n                  })\n                })\n\n                queries.push(\n                  ...gqlAst.definitions.map(d => {\n                    d.text = text\n\n                    innerPath.traverse({\n                      TemplateElement(templateElementPath) {\n                        d.templateLoc = templateElementPath.node.loc\n                      },\n                    })\n\n                    return d\n                  })\n                )\n              },\n            })\n          },\n        })\n\n        // Remove duplicate queries\n        const uniqueQueries = _.uniqBy(queries, q => documentLocations.get(q))\n\n        resolve(uniqueQueries)\n      })\n      .catch(reject)\n  })\n}\n\nconst cache = {}\n\nexport default class FileParser {\n  async parseFile(file: string): Promise<?DocumentNode> {\n    let text\n    try {\n      text = await fs.readFile(file, `utf8`)\n    } catch (err) {\n      report.error(`There was a problem reading the file: ${file}`, err)\n      boundActionCreators.queryExtractionGraphQLError({\n        componentPath: file,\n      })\n      return null\n    }\n\n    if (text.indexOf(`graphql`) === -1) return null\n    const hash = crypto\n      .createHash(`md5`)\n      .update(file)\n      .update(text)\n      .digest(`hex`)\n\n    try {\n      let astDefinitions =\n        cache[hash] || (cache[hash] = await findGraphQLTags(file, text))\n\n      // If any AST definitions were extracted, report success.\n      // This can mean there is none or there was a babel error when\n      // we tried to extract the graphql AST.\n      if (astDefinitions.length > 0) {\n        boundActionCreators.queryExtractedBabelSuccess({\n          componentPath: file,\n        })\n      }\n\n      return astDefinitions.length\n        ? {\n            kind: `Document`,\n            definitions: astDefinitions,\n          }\n        : null\n    } catch (err) {\n      report.error(\n        `There was a problem parsing the GraphQL query in file: ${file}`,\n        err\n      )\n      boundActionCreators.queryExtractionGraphQLError({\n        componentPath: file,\n      })\n      return null\n    }\n  }\n\n  async parseFiles(files: Array<string>): Promise<Map<string, DocumentNode>> {\n    const documents = new Map()\n\n    return Promise.all(\n      files.map(file =>\n        this.parseFile(file).then(doc => {\n          if (!doc) return\n          documents.set(file, doc)\n        })\n      )\n    ).then(() => documents)\n  }\n}\n"],"file":"file-parser.js"}