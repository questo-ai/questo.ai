{"version":3,"sources":["../../../src/redux/actions/restricted.js"],"names":["report","require","actions","addThirdPartySchema","schema","plugin","traceId","type","payload","createTypes","types","reservedExtensionNames","createFieldExtension","extension","dispatch","getState","name","fieldExtensions","schemaCustomization","error","includes","withDeprecationWarning","actionName","action","api","allowedIn","args","warn","map","a","join","withErrorMessage","nodeAPIs","Object","keys","ALLOWED_IN","DEPRECATED_IN","set","availableActionsByAPI","mapAvailableActionsToAPIs","restrictions","actionNames","forEach","deprecatedIn","forbiddenIn","filter","module","exports"],"mappings":"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","sourcesContent":["// @flow\nconst report = require(`gatsby-cli/lib/reporter`)\n\nimport type { Plugin } from \"./types\"\n\nconst actions = {}\n\n/**\n * Add a third-party schema to be merged into main schema. Schema has to be a\n * graphql-js GraphQLSchema object.\n *\n * This schema is going to be merged as-is. This can easily break the main\n * Gatsby schema, so it's user's responsibility to make sure it doesn't happen\n * (by eg namespacing the schema).\n *\n * @availableIn [createSchemaCustomization, sourceNodes]\n *\n * @param {Object} $0\n * @param {GraphQLSchema} $0.schema GraphQL schema to add\n */\nactions.addThirdPartySchema = (\n  { schema }: { schema: GraphQLSchema },\n  plugin: Plugin,\n  traceId?: string\n) => {\n  return {\n    type: `ADD_THIRD_PARTY_SCHEMA`,\n    plugin,\n    traceId,\n    payload: schema,\n  }\n}\n\nimport type GatsbyGraphQLType from \"../../schema/types/type-builders\"\n/**\n * Add type definitions to the GraphQL schema.\n *\n * @availableIn [createSchemaCustomization, sourceNodes]\n *\n * @param {string | GraphQLOutputType | GatsbyGraphQLType | string[] | GraphQLOutputType[] | GatsbyGraphQLType[]} types Type definitions\n *\n * Type definitions can be provided either as\n * [`graphql-js` types](https://graphql.org/graphql-js/), in\n * [GraphQL schema definition language (SDL)](https://graphql.org/learn/)\n * or using Gatsby Type Builders available on the `schema` API argument.\n *\n * Things to note:\n * * type definitions targeting node types, i.e. `MarkdownRemark` and others\n *   added in `sourceNodes` or `onCreateNode` APIs, need to implement the\n *   `Node` interface. Interface fields will be added automatically, but it\n *   is mandatory to label those types with `implements Node`.\n * * by default, explicit type definitions from `createTypes` will be merged\n *   with inferred field types, and default field resolvers for `Date` (which\n *   adds formatting options) and `File` (which resolves the field value as\n *   a `relativePath` foreign-key field) are added. This behavior can be\n *   customised with `@infer`, `@dontInfer` directives or extensions. Fields\n *   may be assigned resolver (and other option like args) with additional\n *   directives. Currently `@dateformat`, `@link`, `@fileByRelativePath` and\n *   `@proxy` are available.\n *\n *\n * Schema customization controls:\n * * `@infer` - run inference on the type and add fields that don't exist on the\n * defined type to it.\n * * `@dontInfer` - don't run any inference on the type\n *\n * Extensions to add resolver options:\n * * `@dateformat` - add date formatting arguments. Accepts `formatString` and\n *   `locale` options that sets the defaults for this field\n * * `@link` - connect to a different Node. Arguments `by` and `from`, which\n *   define which field to compare to on a remote node and which field to use on\n *   the source node\n * * `@fileByRelativePath` - connect to a File node. Same arguments. The\n *   difference from link is that this normalizes the relative path to be\n *   relative from the path where source node is found.\n * * `@proxy` - in case the underlying node data contains field names with\n *   characters that are invalid in GraphQL, `proxy` allows to explicitly\n *   proxy those properties to fields with valid field names. Takes a `from` arg.\n *\n *\n * @example\n * exports.sourceNodes = ({ actions }) => {\n *   const { createTypes } = actions\n *   const typeDefs = `\n *     \"\"\"\n *     Markdown Node\n *     \"\"\"\n *     type MarkdownRemark implements Node @infer {\n *       frontmatter: Frontmatter!\n *     }\n *\n *     \"\"\"\n *     Markdown Frontmatter\n *     \"\"\"\n *     type Frontmatter @infer {\n *       title: String!\n *       author: AuthorJson! @link\n *       date: Date! @dateformat\n *       published: Boolean!\n *       tags: [String!]!\n *     }\n *\n *     \"\"\"\n *     Author information\n *     \"\"\"\n *     # Does not include automatically inferred fields\n *     type AuthorJson implements Node @dontInfer {\n *       name: String!\n *       birthday: Date! @dateformat(locale: \"ru\")\n *     }\n *   `\n *   createTypes(typeDefs)\n * }\n *\n * // using Gatsby Type Builder API\n * exports.sourceNodes = ({ actions, schema }) => {\n *   const { createTypes } = actions\n *   const typeDefs = [\n *     schema.buildObjectType({\n *       name: 'MarkdownRemark',\n *       fields: {\n *         frontmatter: 'Frontmatter!'\n *       },\n *       interfaces: ['Node'],\n *       extensions: {\n *         infer: true,\n *       },\n *     }),\n *     schema.buildObjectType({\n *       name: 'Frontmatter',\n *       fields: {\n *         title: {\n *           type: 'String!',\n *           resolve(parent) {\n *             return parent.title || '(Untitled)'\n *           }\n *         },\n *         author: {\n *           type: 'AuthorJson'\n *           extensions: {\n *             link: {},\n *           },\n *         }\n *         date: {\n *           type: 'Date!'\n *           extensions: {\n *             dateformat: {},\n *           },\n *         },\n *         published: 'Boolean!',\n *         tags: '[String!]!',\n *       }\n *     }),\n *     schema.buildObjectType({\n *       name: 'AuthorJson',\n *       fields: {\n *         name: 'String!'\n *         birthday: {\n *           type: 'Date!'\n *           extensions: {\n *             dateformat: {\n *               locale: 'ru',\n *             },\n *           },\n *         },\n *       },\n *       interfaces: ['Node'],\n *       extensions: {\n *         infer: false,\n *       },\n *     }),\n *   ]\n *   createTypes(typeDefs)\n * }\n */\nactions.createTypes = (\n  types:\n    | string\n    | GraphQLOutputType\n    | GatsbyGraphQLType\n    | Array<string | GraphQLOutputType | GatsbyGraphQLType>,\n  plugin: Plugin,\n  traceId?: string\n) => {\n  return {\n    type: `CREATE_TYPES`,\n    plugin,\n    traceId,\n    payload: types,\n  }\n}\n\nconst { reservedExtensionNames } = require(`../../schema/extensions`)\nimport type GraphQLFieldExtensionDefinition from \"../../schema/extensions\"\n/**\n * Add a field extension to the GraphQL schema.\n *\n * Extensions allow defining custom behavior which can be added to fields\n * via directive (in SDL) or on the `extensions` prop (with Type Builders).\n *\n * The extension definition takes a `name`, an `extend` function, and optional\n * extension `args` for options. The `extend` function has to return a (partial)\n * field config, and receives the extension options and the previous field config\n * as arguments.\n *\n * @availableIn [createSchemaCustomization, sourceNodes]\n *\n * @param {GraphQLFieldExtensionDefinition} extension The field extension definition\n * @example\n * exports.createSchemaCustomization = ({ actions }) => {\n *   const { createFieldExtension } = actions\n *   createFieldExtension({\n *     name: 'motivate',\n *     args: {\n *       caffeine: 'Int'\n *     },\n *     extend(options, prevFieldConfig) {\n *       return {\n *         type: 'String',\n *         args: {\n *           sunshine: {\n *             type: 'Int',\n *             defaultValue: 0,\n *           },\n *         },\n *         resolve(source, args, context, info) {\n *           const motivation = (options.caffeine || 0) - args.sunshine\n *           if (motivation > 5) return 'Work! Work! Work!'\n *           return 'Maybe tomorrow.'\n *         },\n *       }\n *     },\n *   })\n * }\n */\nactions.createFieldExtension = (\n  extension: GraphQLFieldExtensionDefinition,\n  plugin: Plugin,\n  traceId?: string\n) => (dispatch, getState) => {\n  const { name } = extension || {}\n  const { fieldExtensions } = getState().schemaCustomization\n\n  if (!name) {\n    report.error(`The provided field extension must have a \\`name\\` property.`)\n  } else if (reservedExtensionNames.includes(name)) {\n    report.error(\n      `The field extension name \\`${name}\\` is reserved for internal use.`\n    )\n  } else if (fieldExtensions[name]) {\n    report.error(\n      `A field extension with the name \\`${name}\\` has already been registered.`\n    )\n  } else {\n    dispatch({\n      type: `CREATE_FIELD_EXTENSION`,\n      plugin,\n      traceId,\n      payload: { name, extension },\n    })\n  }\n}\n\nconst withDeprecationWarning = (actionName, action, api, allowedIn) => (\n  ...args\n) => {\n  report.warn(\n    `Calling \\`${actionName}\\` in the \\`${api}\\` API is deprecated. ` +\n      `Please use: ${allowedIn.map(a => `\\`${a}\\``).join(`, `)}.`\n  )\n  return action(...args)\n}\n\nconst withErrorMessage = (actionName, api, allowedIn) => () =>\n  // return a thunk that does not dispatch anything\n  () => {\n    report.error(\n      `\\`${actionName}\\` is not available in the \\`${api}\\` API. ` +\n        `Please use: ${allowedIn.map(a => `\\`${a}\\``).join(`, `)}.`\n    )\n  }\n\nconst nodeAPIs = Object.keys(require(`../../utils/api-node-docs`))\n\nconst ALLOWED_IN = `ALLOWED_IN`\nconst DEPRECATED_IN = `DEPRECATED_IN`\n\nconst set = (availableActionsByAPI, api, actionName, action) => {\n  availableActionsByAPI[api] = availableActionsByAPI[api] || {}\n  availableActionsByAPI[api][actionName] = action\n}\n\nconst mapAvailableActionsToAPIs = restrictions => {\n  const availableActionsByAPI = {}\n\n  const actionNames = Object.keys(restrictions)\n  actionNames.forEach(actionName => {\n    const action = actions[actionName]\n\n    const allowedIn = restrictions[actionName][ALLOWED_IN] || []\n    allowedIn.forEach(api =>\n      set(availableActionsByAPI, api, actionName, action)\n    )\n\n    const deprecatedIn = restrictions[actionName][DEPRECATED_IN] || []\n    deprecatedIn.forEach(api =>\n      set(\n        availableActionsByAPI,\n        api,\n        actionName,\n        withDeprecationWarning(actionName, action, api, allowedIn)\n      )\n    )\n\n    const forbiddenIn = nodeAPIs.filter(\n      api => ![...allowedIn, ...deprecatedIn].includes(api)\n    )\n    forbiddenIn.forEach(api =>\n      set(\n        availableActionsByAPI,\n        api,\n        actionName,\n        withErrorMessage(actionName, api, allowedIn)\n      )\n    )\n  })\n\n  return availableActionsByAPI\n}\n\nconst availableActionsByAPI = mapAvailableActionsToAPIs({\n  createFieldExtension: {\n    [ALLOWED_IN]: [`sourceNodes`, `createSchemaCustomization`],\n  },\n  createTypes: {\n    [ALLOWED_IN]: [`sourceNodes`, `createSchemaCustomization`],\n    [DEPRECATED_IN]: [`onPreInit`, `onPreBootstrap`],\n  },\n  addThirdPartySchema: {\n    [ALLOWED_IN]: [`sourceNodes`, `createSchemaCustomization`],\n    [DEPRECATED_IN]: [`onPreInit`, `onPreBootstrap`],\n  },\n})\n\nmodule.exports = { actions, availableActionsByAPI }\n"],"file":"restricted.js"}