{"version":3,"sources":["../../src/schema/schema.js"],"names":["_","require","invariant","isSpecifiedScalarType","isIntrospectionType","defaultFieldResolver","assertValidName","parse","GraphQLNonNull","GraphQLList","ObjectTypeComposer","InterfaceTypeComposer","UnionTypeComposer","InputTypeComposer","ScalarTypeComposer","EnumTypeComposer","apiRunner","report","addNodeInterfaceFields","addInferredType","addInferredTypes","findOne","findManyPaginated","processFieldExtensions","internalExtensionNames","getPagination","getSortInput","getFilterInput","isGatsbyType","GatsbyGraphQLTypeKind","buildSchema","schemaComposer","nodeStore","types","typeMapping","fieldExtensions","thirdPartySchemas","typeConflictReporter","parentSpan","updateSchemaComposer","schema","rebuildSchemaWithSitePage","typeComposer","getOTC","processTypeComposer","module","exports","addTypes","addSetFieldsOnGraphQLNodeTypeFields","Promise","all","Array","from","Set","values","map","checkQueryableInterfaces","addConvenienceChildrenFields","addThirdPartySchemas","addCustomResolveFunctions","hasInterface","addImplicitConvenienceChildrenFields","addTypeToRootQuery","getExtension","forEach","typeOrTypeDef","plugin","parsedTypes","createdFrom","parseTypeDefs","typeDefs","error","reportParsingError","type","processAddedType","createTypeComposerFromGatsbyType","typeName","getTypeName","checkIsAllowedTypeName","has","get","mergeTypes","name","typeOwner","merge","isNamedTypeComposer","extendExtensions","getExtensions","addExtensions","warn","addAsComposer","getResolveType","setResolveType","node","internal","addSchemaMustHaveType","setExtension","directives","getDirectives","args","noDefaultResolvers","hasField","getFieldType","toString","panic","getFieldNames","fieldName","setFieldExtension","getFieldDirectives","getFieldExtensions","Object","keys","filter","includes","definition","getDirective","defaultValue","undefined","arg","argumentDef","find","value","validate","message","hasExtension","endsWith","kind","OBJECT","createTemp","config","interfaces","iface","getIFTC","getType","INPUT_OBJECT","UNION","INTERFACE","ENUM","SCALAR","JSON","stringify","tc","result","nodes","getNodesByType","traceId","fields","addNestedFields","schemaQueryType","getQueryType","queryTC","createTempTC","processThirdPartyTypeFields","Query","addFields","getFields","getTypeMap","createTC","field","getField","fieldType","replace","extendField","intermediateSchema","createResolvers","resolvers","fieldConfig","originalFieldConfig","getFieldConfig","originalTypeName","originalResolver","resolve","fieldTypeName","isArray","stringifyArray","newConfig","source","context","info","parentTypesToChildren","Map","mimeTypesToChildren","typesHandlingMimeTypes","mimeType","set","add","mimeTypes","many","parentType","children","parent","getAnyTC","child","createChildrenField","createChildField","parentTypes","shouldInfer","childNodesByType","groupChildNodesByType","typeChildren","maxChildCount","maxBy","groupBy","c","g","length","camelCase","path","nodeModel","getNodesByIds","ids","flatMap","getNode","removeInputTypeComposer","sortInputTC","filterInputTC","paginationTC","queryName","queryNamePlural","sort","skip","limit","parseTypes","doc","definitions","def","parsedType","typeMapper","makeSchemaDef","push","locations","codeFrameColumns","frame","body","start","linesAbove","linesBelow","arr","item","Error","ofType","v","parseValue","queryableInterfaces","incorrectTypes","getInterfaces","some","t","join"],"mappings":";;AAAA,MAAMA,CAAC,GAAGC,OAAO,CAAE,QAAF,CAAjB;;AACA,MAAMC,SAAS,GAAGD,OAAO,CAAE,WAAF,CAAzB;;AACA,MAAM;AACJE,EAAAA,qBADI;AAEJC,EAAAA,mBAFI;AAGJC,EAAAA,oBAHI;AAIJC,EAAAA,eAJI;AAKJC,EAAAA,KALI;AAMJC,EAAAA,cANI;AAOJC,EAAAA;AAPI,IAQFR,OAAO,CAAE,SAAF,CARX;;AASA,MAAM;AACJS,EAAAA,kBADI;AAEJC,EAAAA,qBAFI;AAGJC,EAAAA,iBAHI;AAIJC,EAAAA,iBAJI;AAKJC,EAAAA,kBALI;AAMJC,EAAAA;AANI,IAOFd,OAAO,CAAE,iBAAF,CAPX;;AASA,MAAMe,SAAS,GAAGf,OAAO,CAAE,0BAAF,CAAzB;;AACA,MAAMgB,MAAM,GAAGhB,OAAO,CAAE,yBAAF,CAAtB;;AACA,MAAM;AAAEiB,EAAAA;AAAF,IAA6BjB,OAAO,CAAE,wBAAF,CAA1C;;AACA,MAAM;AAAEkB,EAAAA,eAAF;AAAmBC,EAAAA;AAAnB,IAAwCnB,OAAO,CAAE,SAAF,CAArD;;AACA,MAAM;AAAEoB,EAAAA,OAAF;AAAWC,EAAAA;AAAX,IAAiCrB,OAAO,CAAE,aAAF,CAA9C;;AACA,MAAM;AACJsB,EAAAA,sBADI;AAEJC,EAAAA;AAFI,IAGFvB,OAAO,CAAE,cAAF,CAHX;;AAIA,MAAM;AAAEwB,EAAAA;AAAF,IAAoBxB,OAAO,CAAE,oBAAF,CAAjC;;AACA,MAAM;AAAEyB,EAAAA;AAAF,IAAmBzB,OAAO,CAAE,cAAF,CAAhC;;AACA,MAAM;AAAE0B,EAAAA;AAAF,IAAqB1B,OAAO,CAAE,gBAAF,CAAlC;;AACA,MAAM;AAAE2B,EAAAA,YAAF;AAAgBC,EAAAA;AAAhB,IAA0C5B,OAAO,CAAE,uBAAF,CAAvD;;AAEA,MAAM6B,WAAW,GAAG,OAAO;AACzBC,EAAAA,cADyB;AAEzBC,EAAAA,SAFyB;AAGzBC,EAAAA,KAHyB;AAIzBC,EAAAA,WAJyB;AAKzBC,EAAAA,eALyB;AAMzBC,EAAAA,iBANyB;AAOzBC,EAAAA,oBAPyB;AAQzBC,EAAAA;AARyB,CAAP,KASd;AACJ,QAAMC,oBAAoB,CAAC;AACzBR,IAAAA,cADyB;AAEzBC,IAAAA,SAFyB;AAGzBC,IAAAA,KAHyB;AAIzBC,IAAAA,WAJyB;AAKzBC,IAAAA,eALyB;AAMzBC,IAAAA,iBANyB;AAOzBC,IAAAA,oBAPyB;AAQzBC,IAAAA;AARyB,GAAD,CAA1B,CADI,CAWJ;;AACA,QAAME,MAAM,GAAGT,cAAc,CAACD,WAAf,EAAf,CAZI,CAaJ;;AACA,SAAOU,MAAP;AACD,CAxBD;;AA0BA,MAAMC,yBAAyB,GAAG,OAAO;AACvCV,EAAAA,cADuC;AAEvCC,EAAAA,SAFuC;AAGvCE,EAAAA,WAHuC;AAIvCC,EAAAA,eAJuC;AAKvCE,EAAAA,oBALuC;AAMvCC,EAAAA;AANuC,CAAP,KAO5B;AACJ,QAAMI,YAAY,GAAGvB,eAAe,CAAC;AACnCY,IAAAA,cADmC;AAEnCW,IAAAA,YAAY,EAAEX,cAAc,CAACY,MAAf,CAAuB,UAAvB,CAFqB;AAGnCX,IAAAA,SAHmC;AAInCK,IAAAA,oBAJmC;AAKnCH,IAAAA,WALmC;AAMnCI,IAAAA;AANmC,GAAD,CAApC;AAQA,QAAMM,mBAAmB,CAAC;AACxBb,IAAAA,cADwB;AAExBW,IAAAA,YAFwB;AAGxBP,IAAAA,eAHwB;AAIxBH,IAAAA,SAJwB;AAKxBM,IAAAA;AALwB,GAAD,CAAzB;AAOA,SAAOP,cAAc,CAACD,WAAf,EAAP;AACD,CAxBD;;AA0BAe,MAAM,CAACC,OAAP,GAAiB;AACfhB,EAAAA,WADe;AAEfW,EAAAA;AAFe,CAAjB;;AAKA,MAAMF,oBAAoB,GAAG,OAAO;AAClCR,EAAAA,cADkC;AAElCC,EAAAA,SAFkC;AAGlCC,EAAAA,KAHkC;AAIlCC,EAAAA,WAJkC;AAKlCC,EAAAA,eALkC;AAMlCC,EAAAA,iBANkC;AAOlCC,EAAAA,oBAPkC;AAQlCC,EAAAA;AARkC,CAAP,KASvB;AACJ,QAAMS,QAAQ,CAAC;AAAEhB,IAAAA,cAAF;AAAkBO,IAAAA,UAAlB;AAA8BL,IAAAA;AAA9B,GAAD,CAAd;AACA,QAAMb,gBAAgB,CAAC;AACrBW,IAAAA,cADqB;AAErBC,IAAAA,SAFqB;AAGrBK,IAAAA,oBAHqB;AAIrBH,IAAAA,WAJqB;AAKrBI,IAAAA;AALqB,GAAD,CAAtB;AAOA,QAAMU,mCAAmC,CAAC;AACxCjB,IAAAA,cADwC;AAExCC,IAAAA,SAFwC;AAGxCM,IAAAA;AAHwC,GAAD,CAAzC;AAKA,QAAMW,OAAO,CAACC,GAAR,CACJC,KAAK,CAACC,IAAN,CAAW,IAAIC,GAAJ,CAAQtB,cAAc,CAACuB,MAAf,EAAR,CAAX,EAA6CC,GAA7C,CAAiDb,YAAY,IAC3DE,mBAAmB,CAAC;AAClBb,IAAAA,cADkB;AAElBW,IAAAA,YAFkB;AAGlBP,IAAAA,eAHkB;AAIlBH,IAAAA,SAJkB;AAKlBM,IAAAA;AALkB,GAAD,CADrB,CADI,CAAN;AAWAkB,EAAAA,wBAAwB,CAAC;AAAEzB,IAAAA;AAAF,GAAD,CAAxB;AACA,QAAM0B,4BAA4B,CAAC;AAAE1B,IAAAA,cAAF;AAAkBO,IAAAA;AAAlB,GAAD,CAAlC;AACA,QAAMoB,oBAAoB,CAAC;AAAE3B,IAAAA,cAAF;AAAkBK,IAAAA,iBAAlB;AAAqCE,IAAAA;AAArC,GAAD,CAA1B;AACA,QAAMqB,yBAAyB,CAAC;AAAE5B,IAAAA,cAAF;AAAkBO,IAAAA;AAAlB,GAAD,CAA/B;AACD,CAtCD;;AAwCA,MAAMM,mBAAmB,GAAG,OAAO;AACjCb,EAAAA,cADiC;AAEjCW,EAAAA,YAFiC;AAGjCP,EAAAA,eAHiC;AAIjCH,EAAAA,SAJiC;AAKjCM,EAAAA;AALiC,CAAP,KAMtB;AACJ,MAAII,YAAY,YAAYhC,kBAA5B,EAAgD;AAC9C,UAAMa,sBAAsB,CAAC;AAC3BQ,MAAAA,cAD2B;AAE3BW,MAAAA,YAF2B;AAG3BP,MAAAA,eAH2B;AAI3BG,MAAAA;AAJ2B,KAAD,CAA5B;;AAMA,QAAII,YAAY,CAACkB,YAAb,CAA2B,MAA3B,CAAJ,EAAuC;AACrC,YAAM1C,sBAAsB,CAAC;AAAEa,QAAAA,cAAF;AAAkBW,QAAAA,YAAlB;AAAgCJ,QAAAA;AAAhC,OAAD,CAA5B;AACA,YAAMuB,oCAAoC,CAAC;AACzC9B,QAAAA,cADyC;AAEzCW,QAAAA,YAFyC;AAGzCV,QAAAA,SAHyC;AAIzCM,QAAAA;AAJyC,OAAD,CAA1C;AAMA,YAAMwB,kBAAkB,CAAC;AAAE/B,QAAAA,cAAF;AAAkBW,QAAAA,YAAlB;AAAgCJ,QAAAA;AAAhC,OAAD,CAAxB;AACD;AACF,GAjBD,MAiBO,IAAII,YAAY,YAAY/B,qBAA5B,EAAmD;AACxD,QAAI+B,YAAY,CAACqB,YAAb,CAA2B,eAA3B,CAAJ,EAAgD;AAC9C;AACA;AACA,YAAMxC,sBAAsB,CAAC;AAC3BQ,QAAAA,cAD2B;AAE3BW,QAAAA,YAF2B;AAG3BP,QAAAA,eAH2B;AAI3BG,QAAAA;AAJ2B,OAAD,CAA5B;AAMA,YAAMwB,kBAAkB,CAAC;AAAE/B,QAAAA,cAAF;AAAkBW,QAAAA,YAAlB;AAAgCJ,QAAAA;AAAhC,OAAD,CAAxB;AACD;AACF;AACF,CArCD;;AAuCA,MAAMS,QAAQ,GAAG,CAAC;AAAEhB,EAAAA,cAAF;AAAkBE,EAAAA,KAAlB;AAAyBK,EAAAA;AAAzB,CAAD,KAA2C;AAC1DL,EAAAA,KAAK,CAAC+B,OAAN,CAAc,CAAC;AAAEC,IAAAA,aAAF;AAAiBC,IAAAA;AAAjB,GAAD,KAA+B;AAC3C,QAAI,OAAOD,aAAP,KAA0B,QAA9B,EAAuC;AACrC,UAAIE,WAAJ;AACA,YAAMC,WAAW,GAAI,KAArB;;AACA,UAAI;AACFD,QAAAA,WAAW,GAAGE,aAAa,CAAC;AAC1BC,UAAAA,QAAQ,EAAEL,aADgB;AAE1BC,UAAAA,MAF0B;AAG1BE,UAAAA,WAH0B;AAI1BrC,UAAAA,cAJ0B;AAK1BO,UAAAA;AAL0B,SAAD,CAA3B;AAOD,OARD,CAQE,OAAOiC,KAAP,EAAc;AACdC,QAAAA,kBAAkB,CAACD,KAAD,CAAlB;AACA;AACD;;AACDJ,MAAAA,WAAW,CAACH,OAAZ,CAAoBS,IAAI,IAAI;AAC1BC,QAAAA,gBAAgB,CAAC;AACf3C,UAAAA,cADe;AAEf0C,UAAAA,IAFe;AAGfnC,UAAAA,UAHe;AAIf8B,UAAAA,WAJe;AAKfF,UAAAA;AALe,SAAD,CAAhB;AAOD,OARD;AASD,KAxBD,MAwBO,IAAItC,YAAY,CAACqC,aAAD,CAAhB,EAAiC;AACtC,YAAMQ,IAAI,GAAGE,gCAAgC,CAAC;AAC5C5C,QAAAA,cAD4C;AAE5C0C,QAAAA,IAAI,EAAER,aAFsC;AAG5C3B,QAAAA;AAH4C,OAAD,CAA7C;;AAMA,UAAImC,IAAJ,EAAU;AACR,cAAMG,QAAQ,GAAGH,IAAI,CAACI,WAAL,EAAjB;AACA,cAAMT,WAAW,GAAI,aAArB;AACAU,QAAAA,sBAAsB,CAACF,QAAD,CAAtB;;AACA,YAAI7C,cAAc,CAACgD,GAAf,CAAmBH,QAAnB,CAAJ,EAAkC;AAChC,gBAAMlC,YAAY,GAAGX,cAAc,CAACiD,GAAf,CAAmBJ,QAAnB,CAArB;AACAK,UAAAA,UAAU,CAAC;AACTlD,YAAAA,cADS;AAETW,YAAAA,YAFS;AAGT+B,YAAAA,IAHS;AAITP,YAAAA,MAJS;AAKTE,YAAAA,WALS;AAMT9B,YAAAA;AANS,WAAD,CAAV;AAQD,SAVD,MAUO;AACLoC,UAAAA,gBAAgB,CAAC;AACf3C,YAAAA,cADe;AAEf0C,YAAAA,IAFe;AAGfnC,YAAAA,UAHe;AAIf8B,YAAAA,WAJe;AAKfF,YAAAA;AALe,WAAD,CAAhB;AAOD;AACF;AACF,KA/BM,MA+BA;AACL,YAAMU,QAAQ,GAAGX,aAAa,CAACiB,IAA/B;AACA,YAAMd,WAAW,GAAI,YAArB;AACAU,MAAAA,sBAAsB,CAACF,QAAD,CAAtB;;AACA,UAAI7C,cAAc,CAACgD,GAAf,CAAmBH,QAAnB,CAAJ,EAAkC;AAChC,cAAMlC,YAAY,GAAGX,cAAc,CAACiD,GAAf,CAAmBJ,QAAnB,CAArB;AACAK,QAAAA,UAAU,CAAC;AACTlD,UAAAA,cADS;AAETW,UAAAA,YAFS;AAGT+B,UAAAA,IAAI,EAAER,aAHG;AAITC,UAAAA,MAJS;AAKTE,UAAAA,WALS;AAMT9B,UAAAA;AANS,SAAD,CAAV;AAQD,OAVD,MAUO;AACLoC,QAAAA,gBAAgB,CAAC;AACf3C,UAAAA,cADe;AAEf0C,UAAAA,IAAI,EAAER,aAFS;AAGf3B,UAAAA,UAHe;AAIf8B,UAAAA,WAJe;AAKfF,UAAAA;AALe,SAAD,CAAhB;AAOD;AACF;AACF,GAhFD;AAiFD,CAlFD;;AAoFA,MAAMe,UAAU,GAAG,CAAC;AAClBlD,EAAAA,cADkB;AAElBW,EAAAA,YAFkB;AAGlB+B,EAAAA,IAHkB;AAIlBP,EAAAA,MAJkB;AAKlBE,EAAAA,WALkB;AAMlB9B,EAAAA;AANkB,CAAD,KAOb;AACJ;AACA,QAAM6C,SAAS,GAAGzC,YAAY,CAACqB,YAAb,CAA2B,QAA3B,CAAlB;;AACA,MACE,CAACG,MAAD,IACAA,MAAM,CAACgB,IAAP,KAAiB,qBADjB,IAEAhB,MAAM,CAACgB,IAAP,KAAgBC,SAHlB,EAIE;AACAzC,IAAAA,YAAY,CAAC0C,KAAb,CAAmBX,IAAnB;;AACA,QAAIY,mBAAmB,CAACZ,IAAD,CAAvB,EAA+B;AAC7B/B,MAAAA,YAAY,CAAC4C,gBAAb,CAA8Bb,IAAI,CAACc,aAAL,EAA9B;AACD;;AACDC,IAAAA,aAAa,CAAC;AAAEzD,MAAAA,cAAF;AAAkBW,MAAAA,YAAlB;AAAgCwB,MAAAA,MAAhC;AAAwCE,MAAAA;AAAxC,KAAD,CAAb;AACA,WAAO,IAAP;AACD,GAXD,MAWO;AACLnD,IAAAA,MAAM,CAACwE,IAAP,CACG,YAAWvB,MAAM,CAACgB,IAAK,sCAAxB,GACG,KAAIxC,YAAY,CAACmC,WAAb,EAA2B,qCADlC,GAEG,mBAAkBM,SAAU,KAHjC;AAKA,WAAO,KAAP;AACD;AACF,CA7BD;;AA+BA,MAAMT,gBAAgB,GAAG,CAAC;AACxB3C,EAAAA,cADwB;AAExB0C,EAAAA,IAFwB;AAGxBnC,EAAAA,UAHwB;AAIxB8B,EAAAA,WAJwB;AAKxBF,EAAAA;AALwB,CAAD,KAMnB;AACJ,QAAMU,QAAQ,GAAG7C,cAAc,CAAC2D,aAAf,CAA6BjB,IAA7B,CAAjB;AACA,QAAM/B,YAAY,GAAGX,cAAc,CAACiD,GAAf,CAAmBJ,QAAnB,CAArB;;AACA,MACElC,YAAY,YAAY/B,qBAAxB,IACA+B,YAAY,YAAY9B,iBAF1B,EAGE;AACA,QAAI,CAAC8B,YAAY,CAACiD,cAAb,EAAL,EAAoC;AAClCjD,MAAAA,YAAY,CAACkD,cAAb,CAA4BC,IAAI,IAAIA,IAAI,CAACC,QAAL,CAAcrB,IAAlD;AACD;AACF;;AACD1C,EAAAA,cAAc,CAACgE,qBAAf,CAAqCrD,YAArC;AAEA8C,EAAAA,aAAa,CAAC;AAAEzD,IAAAA,cAAF;AAAkBW,IAAAA,YAAlB;AAAgCwB,IAAAA,MAAhC;AAAwCE,IAAAA;AAAxC,GAAD,CAAb;AAEA,SAAO1B,YAAP;AACD,CAtBD;;AAwBA,MAAM8C,aAAa,GAAG,CAAC;AACrBzD,EAAAA,cADqB;AAErBW,EAAAA,YAFqB;AAGrBwB,EAAAA,MAHqB;AAIrBE,EAAAA;AAJqB,CAAD,KAKhB;AACJ1B,EAAAA,YAAY,CAACsD,YAAb,CAA2B,aAA3B,EAAyC5B,WAAzC;AACA1B,EAAAA,YAAY,CAACsD,YAAb,CAA2B,QAA3B,EAAoC9B,MAAM,GAAGA,MAAM,CAACgB,IAAV,GAAiB,IAA3D;;AAEA,MAAId,WAAW,KAAM,KAArB,EAA2B;AACzB,UAAM6B,UAAU,GAAGvD,YAAY,CAACwD,aAAb,EAAnB;AACAD,IAAAA,UAAU,CAACjC,OAAX,CAAmB,CAAC;AAAEkB,MAAAA,IAAF;AAAQiB,MAAAA;AAAR,KAAD,KAAoB;AACrC,cAAQjB,IAAR;AACE,aAAM,OAAN;AACA,aAAM,WAAN;AACExC,UAAAA,YAAY,CAACsD,YAAb,CAA2B,OAA3B,EAAmCd,IAAI,KAAM,OAA7C;;AACA,cAAIiB,IAAI,CAACC,kBAAL,IAA2B,IAA/B,EAAqC;AACnC1D,YAAAA,YAAY,CAACsD,YAAb,CACG,qBADH,EAEE,CAACG,IAAI,CAACC,kBAFR;AAID;;AACD;;AACF,aAAM,WAAN;AACE1D,UAAAA,YAAY,CAACsD,YAAb,CAA2B,WAA3B,EAAuCG,IAAvC;AACA;;AACF,aAAM,SAAN;AACEzD,UAAAA,YAAY,CAACsD,YAAb,CAA2B,SAA3B,EAAqCG,IAArC;AACA;;AACF,aAAM,eAAN;AACE,cAAIzD,YAAY,YAAY/B,qBAA5B,EAAmD;AACjD,gBACE,CAAC+B,YAAY,CAAC2D,QAAb,CAAuB,IAAvB,CAAD,IACA3D,YAAY,CAAC4D,YAAb,CAA2B,IAA3B,EAAgCC,QAAhC,OAAgD,KAFlD,EAGE;AACAtF,cAAAA,MAAM,CAACuF,KAAP,CACG,oEAAD,GACG,uDADH,GAEG,KAAI9D,YAAY,CAACmC,WAAb,EAA2B,KAHpC;AAKD;;AACDnC,YAAAA,YAAY,CAACsD,YAAb,CAA2B,eAA3B,EAA2C,IAA3C;AACD;;AACD;;AACF;AAhCF;AAkCD,KAnCD;AAoCD;;AAED,MACEtD,YAAY,YAAYhC,kBAAxB,IACAgC,YAAY,YAAY/B,qBAF1B,EAGE;AACA+B,IAAAA,YAAY,CAAC+D,aAAb,GAA6BzC,OAA7B,CAAqC0C,SAAS,IAAI;AAChDhE,MAAAA,YAAY,CAACiE,iBAAb,CAA+BD,SAA/B,EAA2C,aAA3C,EAAyDtC,WAAzD;AACA1B,MAAAA,YAAY,CAACiE,iBAAb,CACED,SADF,EAEG,QAFH,EAGExC,MAAM,GAAGA,MAAM,CAACgB,IAAV,GAAiB,IAHzB;;AAMA,UAAId,WAAW,KAAM,KAArB,EAA2B;AACzB,cAAM6B,UAAU,GAAGvD,YAAY,CAACkE,kBAAb,CAAgCF,SAAhC,CAAnB;AACAT,QAAAA,UAAU,CAACjC,OAAX,CAAmB,CAAC;AAAEkB,UAAAA,IAAF;AAAQiB,UAAAA;AAAR,SAAD,KAAoB;AACrCzD,UAAAA,YAAY,CAACiE,iBAAb,CAA+BD,SAA/B,EAA0CxB,IAA1C,EAAgDiB,IAAhD;AACD,SAFD;AAGD,OAb+C,CAehD;AACA;AACA;AACA;AACA;;;AACA,YAAMhE,eAAe,GAAGO,YAAY,CAACmE,kBAAb,CAAgCH,SAAhC,CAAxB;AACA,YAAM9B,QAAQ,GAAGlC,YAAY,CAACmC,WAAb,EAAjB;AACAiC,MAAAA,MAAM,CAACC,IAAP,CAAY5E,eAAZ,EACG6E,MADH,CACU9B,IAAI,IAAI,CAAC1D,sBAAsB,CAACyF,QAAvB,CAAgC/B,IAAhC,CADnB,EAEGlB,OAFH,CAEWkB,IAAI,IAAI;AACf,cAAMiB,IAAI,GAAGhE,eAAe,CAAC+C,IAAD,CAA5B;;AACA,YAAI;AACF,gBAAMgC,UAAU,GAAGnF,cAAc,CAACoF,YAAf,CAA4BjC,IAA5B,CAAnB,CADE,CAGF;;AACAgC,UAAAA,UAAU,CAACf,IAAX,CAAgBnC,OAAhB,CAAwB,CAAC;AAAEkB,YAAAA,IAAF;AAAQkC,YAAAA;AAAR,WAAD,KAA4B;AAClD,gBAAIjB,IAAI,CAACjB,IAAD,CAAJ,KAAemC,SAAf,IAA4BD,YAAY,KAAKC,SAAjD,EAA4D;AAC1DlB,cAAAA,IAAI,CAACjB,IAAD,CAAJ,GAAakC,YAAb;AACD;AACF,WAJD;AAMAN,UAAAA,MAAM,CAACC,IAAP,CAAYZ,IAAZ,EAAkBnC,OAAlB,CAA0BsD,GAAG,IAAI;AAC/B,kBAAMC,WAAW,GAAGL,UAAU,CAACf,IAAX,CAAgBqB,IAAhB,CAClB,CAAC;AAAEtC,cAAAA;AAAF,aAAD,KAAcA,IAAI,KAAKoC,GADL,CAApB;;AAGA,gBAAI,CAACC,WAAL,EAAkB;AAChBtG,cAAAA,MAAM,CAACsD,KAAP,CACG,qBAAoBW,IAAK,WAAUN,QAAS,IAAG8B,SAAU,KAA1D,GACG,0BAAyBY,GAAI,KAFlC;AAIA;AACD;;AACD,kBAAMG,KAAK,GAAGtB,IAAI,CAACmB,GAAD,CAAlB;;AACA,gBAAI;AACFI,cAAAA,QAAQ,CAACH,WAAW,CAAC9C,IAAb,EAAmBgD,KAAnB,CAAR;AACD,aAFD,CAEE,OAAOlD,KAAP,EAAc;AACdtD,cAAAA,MAAM,CAACsD,KAAP,CACG,qBAAoBW,IAAK,WAAUN,QAAS,IAAG8B,SAAU,KAA1D,GACG,kBAAiBY,GAAI,0BAAyBG,KAAM,KADvD,GAEElD,KAAK,CAACoD,OAHV;AAKD;AACF,WArBD;AAsBD,SAhCD,CAgCE,OAAOpD,KAAP,EAAc;AACdtD,UAAAA,MAAM,CAACsD,KAAP,CACG,qBAAoBW,IAAK,WAAUN,QAAS,IAAG8B,SAAU,KAA1D,GACG,mBAFL;AAID;AACF,OA1CH;AA2CD,KAjED;AAkED;;AAED,MAAIhE,YAAY,CAACkF,YAAb,CAA2B,qBAA3B,CAAJ,EAAsD;AACpD3G,IAAAA,MAAM,CAACwE,IAAP,CACG,yEAAD,GACG,qEADH,GAEG,sBAHL;AAKD;;AAED,SAAO/C,YAAP;AACD,CAlID;;AAoIA,MAAMoC,sBAAsB,GAAGI,IAAI,IAAI;AACrChF,EAAAA,SAAS,CACPgF,IAAI,KAAM,MADH,EAEN,yDAFM,CAAT;AAIAhF,EAAAA,SAAS,CACP,CAACgF,IAAI,CAAC2C,QAAL,CAAe,aAAf,CAAD,IAAiC,CAAC3C,IAAI,CAAC2C,QAAL,CAAe,WAAf,CAD3B,EAEN,kEAAD,GACG,8CAA6C3C,IAAK,KAH9C,CAAT;AAKAhF,EAAAA,SAAS,CACP,CAAC,CAAE,SAAF,EAAa,MAAb,EAAqB,OAArB,EAA8B,IAA9B,EAAoC,KAApC,EAA2C,MAA3C,EAAmD,QAAnD,EAA4D+G,QAA5D,CAAqE/B,IAArE,CADM,EAEN,sBAAqBA,IAAK,qCAA3B,GACG,wBAHI,CAAT;AAKA5E,EAAAA,eAAe,CAAC4E,IAAD,CAAf;AACD,CAhBD;;AAkBA,MAAMP,gCAAgC,GAAG,CAAC;AACxC5C,EAAAA,cADwC;AAExC0C,EAAAA,IAFwC;AAGxCnC,EAAAA;AAHwC,CAAD,KAInC;AACJ,UAAQmC,IAAI,CAACqD,IAAb;AACE,SAAKjG,qBAAqB,CAACkG,MAA3B;AAAmC;AACjC,eAAOrH,kBAAkB,CAACsH,UAAnB,mBAEAvD,IAAI,CAACwD,MAFL;AAGHC,UAAAA,UAAU,EAAE,MAAM;AAChB,gBAAIzD,IAAI,CAACwD,MAAL,CAAYC,UAAhB,EAA4B;AAC1B,qBAAOzD,IAAI,CAACwD,MAAL,CAAYC,UAAZ,CAAuB3E,GAAvB,CAA2B4E,KAAK,IAAI;AACzC,oBAAI,OAAOA,KAAP,KAAkB,QAAtB,EAA+B;AAC7B,yBAAOpG,cAAc,CAACqG,OAAf,CAAuBD,KAAvB,EAA8BE,OAA9B,EAAP;AACD,iBAFD,MAEO;AACL,yBAAOF,KAAP;AACD;AACF,eANM,CAAP;AAOD,aARD,MAQO;AACL,qBAAO,EAAP;AACD;AACF;AAfE,YAiBLpG,cAjBK,CAAP;AAmBD;;AACD,SAAKF,qBAAqB,CAACyG,YAA3B;AAAyC;AACvC,eAAOzH,iBAAiB,CAACmH,UAAlB,CAA6BvD,IAAI,CAACwD,MAAlC,EAA0ClG,cAA1C,CAAP;AACD;;AACD,SAAKF,qBAAqB,CAAC0G,KAA3B;AAAkC;AAChC,eAAO3H,iBAAiB,CAACoH,UAAlB,mBAEAvD,IAAI,CAACwD,MAFL;AAGHhG,UAAAA,KAAK,EAAE,MAAM;AACX,gBAAIwC,IAAI,CAACwD,MAAL,CAAYhG,KAAhB,EAAuB;AACrB,qBAAOwC,IAAI,CAACwD,MAAL,CAAYhG,KAAZ,CAAkBsB,GAAlB,CAAsBqB,QAAQ,IACnC7C,cAAc,CAACY,MAAf,CAAsBiC,QAAtB,EAAgCyD,OAAhC,EADK,CAAP;AAGD,aAJD,MAIO;AACL,qBAAO,EAAP;AACD;AACF;AAXE,YAaLtG,cAbK,CAAP;AAeD;;AACD,SAAKF,qBAAqB,CAAC2G,SAA3B;AAAsC;AACpC,eAAO7H,qBAAqB,CAACqH,UAAtB,CAAiCvD,IAAI,CAACwD,MAAtC,EAA8ClG,cAA9C,CAAP;AACD;;AACD,SAAKF,qBAAqB,CAAC4G,IAA3B;AAAiC;AAC/B,eAAO1H,gBAAgB,CAACiH,UAAjB,CAA4BvD,IAAI,CAACwD,MAAjC,EAAyClG,cAAzC,CAAP;AACD;;AACD,SAAKF,qBAAqB,CAAC6G,MAA3B;AAAmC;AACjC,eAAO5H,kBAAkB,CAACkH,UAAnB,CAA8BvD,IAAI,CAACwD,MAAnC,EAA2ClG,cAA3C,CAAP;AACD;;AACD;AAAS;AACPd,QAAAA,MAAM,CAACwE,IAAP,CAAa,4BAA2BkD,IAAI,CAACC,SAAL,CAAenE,IAAI,CAACwD,MAApB,CAA4B,EAApE;AACA,eAAO,IAAP;AACD;AAtDH;AAwDD,CA7DD;;AA+DA,MAAMjF,mCAAmC,GAAG,CAAC;AAC3CjB,EAAAA,cAD2C;AAE3CC,EAAAA,SAF2C;AAG3CM,EAAAA;AAH2C,CAAD,KAK1CW,OAAO,CAACC,GAAR,CACEC,KAAK,CAACC,IAAN,CAAWrB,cAAc,CAACuB,MAAf,EAAX,EAAoCC,GAApC,CAAwC,MAAMsF,EAAN,IAAY;AAClD,MAAIA,EAAE,YAAYnI,kBAAd,IAAoCmI,EAAE,CAACjF,YAAH,CAAiB,MAAjB,CAAxC,EAAiE;AAC/D,UAAMgB,QAAQ,GAAGiE,EAAE,CAAChE,WAAH,EAAjB;AACA,UAAMiE,MAAM,GAAG,MAAM9H,SAAS,CAAE,4BAAF,EAA+B;AAC3DyD,MAAAA,IAAI,EAAE;AACJS,QAAAA,IAAI,EAAEN,QADF;AAEJmE,QAAAA,KAAK,EAAE/G,SAAS,CAACgH,cAAV,CAAyBpE,QAAzB;AAFH,OADqD;AAK3DqE,MAAAA,OAAO,EAAG,oCALiD;AAM3D3G,MAAAA;AAN2D,KAA/B,CAA9B;;AAQA,QAAIwG,MAAJ,EAAY;AACV;AACA;AACA;AACA;AACAA,MAAAA,MAAM,CAAC9E,OAAP,CAAekF,MAAM,IAAIL,EAAE,CAACM,eAAH,CAAmBD,MAAnB,CAAzB;AACD;AACF;AACF,CAnBD,CADF,CALF;;AA4BA,MAAMxF,oBAAoB,GAAG,CAAC;AAC5B3B,EAAAA,cAD4B;AAE5BK,EAAAA,iBAF4B;AAG5BE,EAAAA;AAH4B,CAAD,KAIvB;AACJF,EAAAA,iBAAiB,CAAC4B,OAAlB,CAA0BxB,MAAM,IAAI;AAClC,UAAM4G,eAAe,GAAG5G,MAAM,CAAC6G,YAAP,EAAxB;AACA,UAAMC,OAAO,GAAGvH,cAAc,CAACwH,YAAf,CAA4BH,eAA5B,CAAhB;AACAI,IAAAA,2BAA2B,CAAC;AAAE9G,MAAAA,YAAY,EAAE4G,OAAhB;AAAyBF,MAAAA;AAAzB,KAAD,CAA3B;AACArH,IAAAA,cAAc,CAAC0H,KAAf,CAAqBC,SAArB,CAA+BJ,OAAO,CAACK,SAAR,EAA/B,EAJkC,CAMlC;AACA;;AACA,UAAM1H,KAAK,GAAGO,MAAM,CAACoH,UAAP,EAAd;AACA9C,IAAAA,MAAM,CAACC,IAAP,CAAY9E,KAAZ,EAAmB+B,OAAnB,CAA2BY,QAAQ,IAAI;AACrC,YAAMH,IAAI,GAAGxC,KAAK,CAAC2C,QAAD,CAAlB;;AACA,UACEH,IAAI,KAAK2E,eAAT,IACA,CAACjJ,qBAAqB,CAACsE,IAAD,CADtB,IAEA,CAACrE,mBAAmB,CAACqE,IAAD,CAFpB,IAGAA,IAAI,CAACS,IAAL,KAAe,MAHf,IAIAT,IAAI,CAACS,IAAL,KAAe,MALjB,EAME;AACA,cAAMxC,YAAY,GAAGX,cAAc,CAAC8H,QAAf,CAAwBpF,IAAxB,CAArB;;AACA,YACE/B,YAAY,YAAYhC,kBAAxB,IACAgC,YAAY,YAAY/B,qBAF1B,EAGE;AACA6I,UAAAA,2BAA2B,CAAC;AAAE9G,YAAAA,YAAF;AAAgB0G,YAAAA;AAAhB,WAAD,CAA3B;AACD;;AACD1G,QAAAA,YAAY,CAACsD,YAAb,CAA2B,aAA3B,EAA0C,kBAA1C;AACAjE,QAAAA,cAAc,CAACgE,qBAAf,CAAqCrD,YAArC;AACD;AACF,KAnBD;AAoBD,GA7BD;AA8BD,CAnCD;;AAqCA,MAAM8G,2BAA2B,GAAG,CAAC;AAAE9G,EAAAA,YAAF;AAAgB0G,EAAAA;AAAhB,CAAD,KAAuC;AACzE;AACA1G,EAAAA,YAAY,CAAC+D,aAAb,GAA6BzC,OAA7B,CAAqC0C,SAAS,IAAI;AAChD,UAAMoD,KAAK,GAAGpH,YAAY,CAACqH,QAAb,CAAsBrD,SAAtB,CAAd;AACA,UAAMsD,SAAS,GAAGF,KAAK,CAACrF,IAAN,CAAW8B,QAAX,EAAlB;;AACA,QAAIyD,SAAS,CAACC,OAAV,CAAkB,SAAlB,EAA8B,EAA9B,MAAqCb,eAAe,CAAClE,IAAzD,EAA+D;AAC7DxC,MAAAA,YAAY,CAACwH,WAAb,CAAyBxD,SAAzB,EAAoC;AAClCjC,QAAAA,IAAI,EAAEuF,SAAS,CAACC,OAAV,CAAkBb,eAAe,CAAClE,IAAlC,EAAyC,OAAzC;AAD4B,OAApC;AAGD;AACF,GARD;AASD,CAXD;;AAaA,MAAMvB,yBAAyB,GAAG,OAAO;AAAE5B,EAAAA,cAAF;AAAkBO,EAAAA;AAAlB,CAAP,KAA0C;AAC1E,QAAM6H,kBAAkB,GAAGpI,cAAc,CAACD,WAAf,EAA3B;;AACA,QAAMsI,eAAe,GAAGC,SAAS,IAAI;AACnCvD,IAAAA,MAAM,CAACC,IAAP,CAAYsD,SAAZ,EAAuBrG,OAAvB,CAA+BY,QAAQ,IAAI;AACzC,YAAMsE,MAAM,GAAGmB,SAAS,CAACzF,QAAD,CAAxB;;AACA,UAAI7C,cAAc,CAACgD,GAAf,CAAmBH,QAAnB,CAAJ,EAAkC;AAChC,cAAMiE,EAAE,GAAG9G,cAAc,CAACY,MAAf,CAAsBiC,QAAtB,CAAX;AACAkC,QAAAA,MAAM,CAACC,IAAP,CAAYmC,MAAZ,EAAoBlF,OAApB,CAA4B0C,SAAS,IAAI;AACvC,gBAAM4D,WAAW,GAAGpB,MAAM,CAACxC,SAAD,CAA1B;;AACA,cAAImC,EAAE,CAACxC,QAAH,CAAYK,SAAZ,CAAJ,EAA4B;AAC1B,kBAAM6D,mBAAmB,GAAG1B,EAAE,CAAC2B,cAAH,CAAkB9D,SAAlB,CAA5B;AACA,kBAAM+D,gBAAgB,GAAGF,mBAAmB,CAAC9F,IAApB,CAAyB8B,QAAzB,EAAzB;AACA,kBAAMmE,gBAAgB,GAAGH,mBAAmB,CAACI,OAA7C;AACA,gBAAIC,aAAJ;;AACA,gBAAIN,WAAW,CAAC7F,IAAhB,EAAsB;AACpBmG,cAAAA,aAAa,GAAGzH,KAAK,CAAC0H,OAAN,CAAcP,WAAW,CAAC7F,IAA1B,IACZqG,cAAc,CAACR,WAAW,CAAC7F,IAAb,CADF,GAEZ6F,WAAW,CAAC7F,IAAZ,CAAiB8B,QAAjB,EAFJ;AAGD;;AAED,gBACE,CAACqE,aAAD,IACAA,aAAa,CAACX,OAAd,CAAsB,IAAtB,EAA6B,EAA7B,MACEQ,gBAAgB,CAACR,OAAjB,CAAyB,IAAzB,EAAgC,EAAhC,CAFF,IAGApB,EAAE,CAAC9E,YAAH,CAAiB,aAAjB,MAAoC,kBAJtC,EAKE;AACA,oBAAMgH,SAAS,GAAG,EAAlB;;AACA,kBAAIT,WAAW,CAAC7F,IAAhB,EAAsB;AACpBsG,gBAAAA,SAAS,CAACtG,IAAV,GAAiB6F,WAAW,CAAC7F,IAA7B;AACD;;AACD,kBAAI6F,WAAW,CAACnE,IAAhB,EAAsB;AACpB4E,gBAAAA,SAAS,CAAC5E,IAAV,GAAiBmE,WAAW,CAACnE,IAA7B;AACD;;AACD,kBAAImE,WAAW,CAACK,OAAhB,EAAyB;AACvBI,gBAAAA,SAAS,CAACJ,OAAV,GAAoB,CAACK,MAAD,EAAS7E,IAAT,EAAe8E,OAAf,EAAwBC,IAAxB,KAClBZ,WAAW,CAACK,OAAZ,CAAoBK,MAApB,EAA4B7E,IAA5B,EAAkC8E,OAAlC,oBACKC,IADL;AAEER,kBAAAA,gBAAgB,EAAEA,gBAAgB,IAAIrK;AAFxC,mBADF;AAKD;;AACDwI,cAAAA,EAAE,CAACqB,WAAH,CAAexD,SAAf,EAA0BqE,SAA1B;AACD,aArBD,MAqBO,IAAIH,aAAJ,EAAmB;AACxB3J,cAAAA,MAAM,CAACwE,IAAP,CACG,iDAAD,GACG,KAAIb,QAAS,IAAG8B,SAAU,kBAAiBkE,aAAc,MAD5D,GAEG,4BAA2BH,gBAAiB,oBAF/C,GAGG,2DAJL;AAMD;AACF,WAxCD,MAwCO;AACL5B,YAAAA,EAAE,CAACa,SAAH,CAAa;AAAE,eAAChD,SAAD,GAAa4D;AAAf,aAAb;AACD;AACF,SA7CD;AA8CD,OAhDD,MAgDO;AACLrJ,QAAAA,MAAM,CAACwE,IAAP,CACG,mDAAkDb,QAAS,UAA5D,GACG,mEADH,GAEG,0BAHL;AAKD;AACF,KAzDD;AA0DD,GA3DD;;AA4DA,QAAM5D,SAAS,CAAE,iBAAF,EAAoB;AACjCmJ,IAAAA,kBADiC;AAEjCC,IAAAA,eAFiC;AAGjCnB,IAAAA,OAAO,EAAG,yBAHuB;AAIjC3G,IAAAA;AAJiC,GAApB,CAAf;AAMD,CApED;;AAsEA,MAAMmB,4BAA4B,GAAG,CAAC;AAAE1B,EAAAA;AAAF,CAAD,KAAwB;AAC3D,QAAMoJ,qBAAqB,GAAG,IAAIC,GAAJ,EAA9B;AACA,QAAMC,mBAAmB,GAAG,IAAID,GAAJ,EAA5B;AACA,QAAME,sBAAsB,GAAG,IAAIF,GAAJ,EAA/B;AAEArJ,EAAAA,cAAc,CAACiC,OAAf,CAAuBS,IAAI,IAAI;AAC7B,QACE,CAACA,IAAI,YAAY/D,kBAAhB,IACC+D,IAAI,YAAY9D,qBADlB,KAEA8D,IAAI,CAACmD,YAAL,CAAmB,WAAnB,CAHF,EAIE;AACA,YAAM;AAAE3F,QAAAA;AAAF,UAAYwC,IAAI,CAACV,YAAL,CAAmB,WAAnB,CAAlB;AACA,UAAIV,GAAJ,CAAQpB,KAAR,EAAe+B,OAAf,CAAuBuH,QAAQ,IAAI;AACjC,YAAI,CAACD,sBAAsB,CAACvG,GAAvB,CAA2BwG,QAA3B,CAAL,EAA2C;AACzCD,UAAAA,sBAAsB,CAACE,GAAvB,CAA2BD,QAA3B,EAAqC,IAAIlI,GAAJ,EAArC;AACD;;AACDiI,QAAAA,sBAAsB,CAACtG,GAAvB,CAA2BuG,QAA3B,EAAqCE,GAArC,CAAyChH,IAAzC;AACD,OALD;AAMD;;AAED,QACE,CAACA,IAAI,YAAY/D,kBAAhB,IACC+D,IAAI,YAAY9D,qBADlB,KAEA8D,IAAI,CAACmD,YAAL,CAAmB,SAAnB,CAHF,EAIE;AACA,UAAInD,IAAI,YAAY/D,kBAAhB,IAAsC,CAAC+D,IAAI,CAACb,YAAL,CAAmB,MAAnB,CAA3C,EAAsE;AACpE3C,QAAAA,MAAM,CAACsD,KAAP,CACG,8FAAD,GACG,kCAAiCE,IAAI,CAACI,WAAL,EAAmB,KAFzD;AAIA;AACD;;AACD,UACEJ,IAAI,YAAY9D,qBAAhB,IACA,CAAC8D,IAAI,CAACmD,YAAL,CAAmB,eAAnB,CAFH,EAGE;AACA3G,QAAAA,MAAM,CAACsD,KAAP,CACG,qEAAD,GACG,0CADH,GAEG,kCAAiCE,IAAI,CAACI,WAAL,EAAmB,KAHzD;AAKA;AACD;;AAED,YAAM;AAAE5C,QAAAA,KAAF;AAASyJ,QAAAA,SAAT;AAAoBC,QAAAA;AAApB,UAA6BlH,IAAI,CAACV,YAAL,CAAmB,SAAnB,CAAnC;AACA,UAAIV,GAAJ,CAAQpB,KAAR,EAAe+B,OAAf,CAAuB4H,UAAU,IAAI;AACnC,YAAI,CAACT,qBAAqB,CAACpG,GAAtB,CAA0B6G,UAA1B,CAAL,EAA4C;AAC1CT,UAAAA,qBAAqB,CAACK,GAAtB,CAA0BI,UAA1B,EAAsC,IAAIR,GAAJ,EAAtC;AACD;;AACDD,QAAAA,qBAAqB,CAACnG,GAAtB,CAA0B4G,UAA1B,EAAsCJ,GAAtC,CAA0C/G,IAA1C,EAAgDkH,IAAhD;AACD,OALD;AAMA,UAAItI,GAAJ,CAAQqI,SAAR,EAAmB1H,OAAnB,CAA2BuH,QAAQ,IAAI;AACrC,YAAI,CAACF,mBAAmB,CAACtG,GAApB,CAAwBwG,QAAxB,CAAL,EAAwC;AACtCF,UAAAA,mBAAmB,CAACG,GAApB,CAAwBD,QAAxB,EAAkC,IAAIH,GAAJ,EAAlC;AACD;;AACDC,QAAAA,mBAAmB,CAACrG,GAApB,CAAwBuG,QAAxB,EAAkCC,GAAlC,CAAsC/G,IAAtC,EAA4CkH,IAA5C;AACD,OALD;AAMD;AACF,GArDD;AAuDAR,EAAAA,qBAAqB,CAACnH,OAAtB,CAA8B,CAAC6H,QAAD,EAAWC,MAAX,KAAsB;AAClD,UAAMpJ,YAAY,GAAGX,cAAc,CAACgK,QAAf,CAAwBD,MAAxB,CAArB;;AACA,QACEpJ,YAAY,YAAY/B,qBAAxB,IACA,CAAC+B,YAAY,CAACkF,YAAb,CAA2B,eAA3B,CAFH,EAGE;AACA3G,MAAAA,MAAM,CAACsD,KAAP,CACG,uEAAD,GACG,2DADH,GAEG,kCAAiC7B,YAAY,CAACmC,WAAb,EAA2B,KAHjE;AAKA;AACD;;AACDgH,IAAAA,QAAQ,CAAC7H,OAAT,CAAiB,CAAC2H,IAAD,EAAOK,KAAP,KAAiB;AAChC,UAAIL,IAAJ,EAAU;AACRjJ,QAAAA,YAAY,CAACgH,SAAb,CAAuBuC,mBAAmB,CAACD,KAAK,CAACnH,WAAN,EAAD,CAA1C;AACD,OAFD,MAEO;AACLnC,QAAAA,YAAY,CAACgH,SAAb,CAAuBwC,gBAAgB,CAACF,KAAK,CAACnH,WAAN,EAAD,CAAvC;AACD;AACF,KAND;AAOD,GApBD;AAsBAwG,EAAAA,mBAAmB,CAACrH,OAApB,CAA4B,CAAC6H,QAAD,EAAWN,QAAX,KAAwB;AAClD,UAAMY,WAAW,GAAGb,sBAAsB,CAACtG,GAAvB,CAA2BuG,QAA3B,CAApB;;AACA,QAAIY,WAAJ,EAAiB;AACfA,MAAAA,WAAW,CAACnI,OAAZ,CAAoB8H,MAAM,IAAI;AAC5B,cAAMpJ,YAAY,GAAGX,cAAc,CAACgK,QAAf,CAAwBD,MAAxB,CAArB;;AACA,YACEpJ,YAAY,YAAY/B,qBAAxB,IACA,CAAC+B,YAAY,CAACkF,YAAb,CAA2B,eAA3B,CAFH,EAGE;AACA3G,UAAAA,MAAM,CAACsD,KAAP,CACG,uEAAD,GACG,2DADH,GAEG,kCAAiC7B,YAAY,CAACmC,WAAb,EAA2B,KAHjE;AAKA;AACD;;AACDgH,QAAAA,QAAQ,CAAC7H,OAAT,CAAiB,CAAC2H,IAAD,EAAOK,KAAP,KAAiB;AAChC,cAAIL,IAAJ,EAAU;AACRjJ,YAAAA,YAAY,CAACgH,SAAb,CAAuBuC,mBAAmB,CAACD,KAAK,CAACnH,WAAN,EAAD,CAA1C;AACD,WAFD,MAEO;AACLnC,YAAAA,YAAY,CAACgH,SAAb,CAAuBwC,gBAAgB,CAACF,KAAK,CAACnH,WAAN,EAAD,CAAvC;AACD;AACF,SAND;AAOD,OApBD;AAqBD;AACF,GAzBD;AA0BD,CA5GD;;AA8GA,MAAMhB,oCAAoC,GAAG,CAAC;AAC5C9B,EAAAA,cAD4C;AAE5CW,EAAAA,YAF4C;AAG5CV,EAAAA;AAH4C,CAAD,KAIvC;AACJ,QAAMoK,WAAW,GAAG1J,YAAY,CAACqB,YAAb,CAA2B,OAA3B,CAApB,CADI,CAEJ;AACA;AACA;AACA;AACA;;AAEA,QAAMgF,KAAK,GAAG/G,SAAS,CAACgH,cAAV,CAAyBtG,YAAY,CAACmC,WAAb,EAAzB,CAAd;AAEA,QAAMwH,gBAAgB,GAAGC,qBAAqB,CAAC;AAAEtK,IAAAA,SAAF;AAAa+G,IAAAA;AAAb,GAAD,CAA9C;AAEAjC,EAAAA,MAAM,CAACC,IAAP,CAAYsF,gBAAZ,EAA8BrI,OAA9B,CAAsCY,QAAQ,IAAI;AAChD,UAAM2H,YAAY,GAAGF,gBAAgB,CAACzH,QAAD,CAArC;;AACA,UAAM4H,aAAa,GAAGxM,CAAC,CAACyM,KAAF,CACpBzM,CAAC,CAACsD,MAAF,CAAStD,CAAC,CAAC0M,OAAF,CAAUH,YAAV,EAAwBI,CAAC,IAAIA,CAAC,CAACb,MAA/B,CAAT,CADoB,EAEpBc,CAAC,IAAIA,CAAC,CAACC,MAFa,EAGpBA,MAHF,CAFgD,CAOhD;;;AACA,QAAIT,WAAW,KAAK,KAApB,EAA2B;AACzB,YAAM1F,SAAS,GAAG1G,CAAC,CAAC8M,SAAF,CACf,GAAEN,aAAa,GAAG,CAAhB,GAAqB,UAArB,GAAkC,OAAO,IAAG5H,QAAS,EADxC,CAAlB;;AAGA,UAAI,CAAClC,YAAY,CAAC2D,QAAb,CAAsBK,SAAtB,CAAL,EAAuC;AACrCzF,QAAAA,MAAM,CAACwE,IAAP,CACG,oEAAD,GACG,8DADH,GAEG,iCAFH,GAGG,6DAHH,GAIG,wCAJH,GAKG,gCAA+B/C,YAAY,CAACmC,WAAb,EAA2B,UAL7D,GAMG,eAAc6B,SAAU,WAP7B;AASD;AACF;;AAED,QAAI8F,aAAa,GAAG,CAApB,EAAuB;AACrB9J,MAAAA,YAAY,CAACgH,SAAb,CAAuBuC,mBAAmB,CAACrH,QAAD,CAA1C;AACD,KAFD,MAEO;AACLlC,MAAAA,YAAY,CAACgH,SAAb,CAAuBwC,gBAAgB,CAACtH,QAAD,CAAvC;AACD;AACF,GA9BD;AA+BD,CA/CD;;AAiDA,MAAMqH,mBAAmB,GAAGrH,QAAQ,IAAI;AACtC,SAAO;AACL,KAAC5E,CAAC,CAAC8M,SAAF,CAAa,YAAWlI,QAAS,EAAjC,CAAD,GAAuC;AACrCH,MAAAA,IAAI,EAAE,MAAM,CAACG,QAAD,CADyB;;AAErC+F,MAAAA,OAAO,CAACK,MAAD,EAAS7E,IAAT,EAAe8E,OAAf,EAAwB;AAC7B,cAAM;AAAE8B,UAAAA;AAAF,YAAW9B,OAAjB;AACA,eAAOA,OAAO,CAAC+B,SAAR,CAAkBC,aAAlB,CACL;AAAEC,UAAAA,GAAG,EAAElC,MAAM,CAACa,QAAd;AAAwBpH,UAAAA,IAAI,EAAEG;AAA9B,SADK,EAEL;AAAEmI,UAAAA;AAAF,SAFK,CAAP;AAID;;AARoC;AADlC,GAAP;AAYD,CAbD;;AAeA,MAAMb,gBAAgB,GAAGtH,QAAQ,IAAI;AACnC,SAAO;AACL,KAAC5E,CAAC,CAAC8M,SAAF,CAAa,SAAQlI,QAAS,EAA9B,CAAD,GAAoC;AAClCH,MAAAA,IAAI,EAAE,MAAMG,QADsB;;AAElC,YAAM+F,OAAN,CAAcK,MAAd,EAAsB7E,IAAtB,EAA4B8E,OAA5B,EAAqC;AACnC,cAAM;AAAE8B,UAAAA;AAAF,YAAW9B,OAAjB;AACA,cAAMnC,MAAM,GAAG,MAAMmC,OAAO,CAAC+B,SAAR,CAAkBC,aAAlB,CACnB;AAAEC,UAAAA,GAAG,EAAElC,MAAM,CAACa,QAAd;AAAwBpH,UAAAA,IAAI,EAAEG;AAA9B,SADmB,EAEnB;AAAEmI,UAAAA;AAAF,SAFmB,CAArB;;AAIA,YAAIjE,MAAM,IAAIA,MAAM,CAAC+D,MAAP,GAAgB,CAA9B,EAAiC;AAC/B,iBAAO/D,MAAM,CAAC,CAAD,CAAb;AACD,SAFD,MAEO;AACL,iBAAO,IAAP;AACD;AACF;;AAbiC;AAD/B,GAAP;AAiBD,CAlBD;;AAoBA,MAAMwD,qBAAqB,GAAG,CAAC;AAAEtK,EAAAA,SAAF;AAAa+G,EAAAA;AAAb,CAAD,KAC5B/I,CAAC,CAAC+I,KAAD,CAAD,CACGoE,OADH,CACWtH,IAAI,IAAI,CAACA,IAAI,CAACgG,QAAL,IAAiB,EAAlB,EAAsBtI,GAAtB,CAA0BvB,SAAS,CAACoL,OAApC,CADnB,EAEGV,OAFH,CAEW7G,IAAI,IAAKA,IAAI,CAACC,QAAL,GAAgBD,IAAI,CAACC,QAAL,CAAcrB,IAA9B,GAAqC4C,SAFzD,EAGGI,KAHH,EADF;;AAMA,MAAM3D,kBAAkB,GAAG,CAAC;AAAE/B,EAAAA,cAAF;AAAkBW,EAAAA;AAAlB,CAAD,KAAsC;AAC/D;AACA;AACA;AACAA,EAAAA,YAAY,CAAC2K,uBAAb;AAEA,QAAMC,WAAW,GAAG5L,YAAY,CAAC;AAC/BK,IAAAA,cAD+B;AAE/BW,IAAAA;AAF+B,GAAD,CAAhC;AAIA,QAAM6K,aAAa,GAAG5L,cAAc,CAAC;AACnCI,IAAAA,cADmC;AAEnCW,IAAAA;AAFmC,GAAD,CAApC;AAIA,QAAM8K,YAAY,GAAG/L,aAAa,CAAC;AACjCM,IAAAA,cADiC;AAEjCW,IAAAA;AAFiC,GAAD,CAAlC;AAKA,QAAMkC,QAAQ,GAAGlC,YAAY,CAACmC,WAAb,EAAjB,CAnB+D,CAoB/D;;AACA,QAAM4I,SAAS,GAAGzN,CAAC,CAAC8M,SAAF,CAAYlI,QAAZ,CAAlB;;AACA,QAAM8I,eAAe,GAAG1N,CAAC,CAAC8M,SAAF,CAAa,OAAMlI,QAAS,EAA5B,CAAxB;;AAEA7C,EAAAA,cAAc,CAAC0H,KAAf,CAAqBC,SAArB,CAA+B;AAC7B,KAAC+D,SAAD,GAAa;AACXhJ,MAAAA,IAAI,EAAE/B,YADK;AAEXyD,MAAAA,IAAI,oBACCoH,aAAa,CAAC5D,SAAd,EADD,CAFO;AAKXgB,MAAAA,OAAO,EAAEtJ,OAAO,CAACuD,QAAD;AALL,KADgB;AAQ7B,KAAC8I,eAAD,GAAmB;AACjBjJ,MAAAA,IAAI,EAAE+I,YADW;AAEjBrH,MAAAA,IAAI,EAAE;AACJa,QAAAA,MAAM,EAAEuG,aADJ;AAEJI,QAAAA,IAAI,EAAEL,WAFF;AAGJM,QAAAA,IAAI,EAAG,KAHH;AAIJC,QAAAA,KAAK,EAAG;AAJJ,OAFW;AAQjBlD,MAAAA,OAAO,EAAErJ,iBAAiB,CAACsD,QAAD;AART;AARU,GAA/B;AAmBD,CA3CD;;AA6CA,MAAMkJ,UAAU,GAAG,CAAC;AAClBC,EAAAA,GADkB;AAElB7J,EAAAA,MAFkB;AAGlBE,EAAAA,WAHkB;AAIlBrC,EAAAA,cAJkB;AAKlBO,EAAAA;AALkB,CAAD,KAMb;AACJ,QAAML,KAAK,GAAG,EAAd;AACA8L,EAAAA,GAAG,CAACC,WAAJ,CAAgBhK,OAAhB,CAAwBiK,GAAG,IAAI;AAC7B,UAAM/I,IAAI,GAAG+I,GAAG,CAAC/I,IAAJ,CAASuC,KAAtB;AACA3C,IAAAA,sBAAsB,CAACI,IAAD,CAAtB;;AAEA,QAAInD,cAAc,CAACgD,GAAf,CAAmBG,IAAnB,CAAJ,EAA8B;AAC5B;AACA;AACA;AAEA;AACA,YAAMxC,YAAY,GAAGX,cAAc,CAACiD,GAAf,CAAmBE,IAAnB,CAArB,CAN4B,CAQ5B;AACA;;AACA,YAAMgJ,UAAU,GAAGnM,cAAc,CAACoM,UAAf,CAA0BC,aAA1B,CAAwCH,GAAxC,CAAnB,CAV4B,CAY5B;;AACAhJ,MAAAA,UAAU,CAAC;AACTlD,QAAAA,cADS;AAETW,QAAAA,YAFS;AAGT+B,QAAAA,IAAI,EAAEyJ,UAHG;AAIThK,QAAAA,MAJS;AAKTE,QAAAA,WALS;AAMT9B,QAAAA;AANS,OAAD,CAAV,CAb4B,CAsB5B;AACA;;AACAP,MAAAA,cAAc,CAACoM,UAAf,CAA0B3C,GAA1B,CAA8B9I,YAAY,CAACmC,WAAb,EAA9B,EAA0DnC,YAA1D;AACD,KAzBD,MAyBO;AACL,YAAMwL,UAAU,GAAGnM,cAAc,CAACoM,UAAf,CAA0BC,aAA1B,CAAwCH,GAAxC,CAAnB;AACAhM,MAAAA,KAAK,CAACoM,IAAN,CAAWH,UAAX;AACD;AACF,GAjCD;AAkCA,SAAOjM,KAAP;AACD,CA3CD;;AA6CA,MAAMoC,aAAa,GAAG,CAAC;AACrBC,EAAAA,QADqB;AAErBJ,EAAAA,MAFqB;AAGrBE,EAAAA,WAHqB;AAIrBrC,EAAAA,cAJqB;AAKrBO,EAAAA;AALqB,CAAD,KAMhB;AACJ,QAAMyL,GAAG,GAAGxN,KAAK,CAAC+D,QAAD,CAAjB;AACA,SAAOwJ,UAAU,CAAC;AAAEC,IAAAA,GAAF;AAAO7J,IAAAA,MAAP;AAAeE,IAAAA,WAAf;AAA4BrC,IAAAA,cAA5B;AAA4CO,IAAAA;AAA5C,GAAD,CAAjB;AACD,CATD;;AAWA,MAAMkC,kBAAkB,GAAGD,KAAK,IAAI;AAClC,QAAM;AAAEoD,IAAAA,OAAF;AAAWqD,IAAAA,MAAX;AAAmBsD,IAAAA;AAAnB,MAAiC/J,KAAvC;;AAEA,MAAIyG,MAAM,IAAIsD,SAAV,IAAuBA,SAAS,CAACzB,MAArC,EAA6C;AAC3C,UAAM;AAAE0B,MAAAA;AAAF,QAAuBtO,OAAO,CAAE,mBAAF,CAApC;;AAEA,UAAMuO,KAAK,GAAGD,gBAAgB,CAC5BvD,MAAM,CAACyD,IADqB,EAE5B;AAAEC,MAAAA,KAAK,EAAEJ,SAAS,CAAC,CAAD;AAAlB,KAF4B,EAG5B;AAAEK,MAAAA,UAAU,EAAE,CAAd;AAAiBC,MAAAA,UAAU,EAAE;AAA7B,KAH4B,CAA9B;AAKA3N,IAAAA,MAAM,CAACuF,KAAP,CACG,uEAAD,GACEmB,OADF,GAEG,MAFH,GAGE6G,KAHF,GAIG,IALL;AAOD,GAfD,MAeO;AACL,UAAMjK,KAAN;AACD;AACF,CArBD;;AAuBA,MAAMuG,cAAc,GAAG+D,GAAG,IACvB,IAAGA,GAAG,CAACtL,GAAJ,CAAQuL,IAAI,IACd3L,KAAK,CAAC0H,OAAN,CAAciE,IAAd,IAAsBhE,cAAc,CAACgE,IAAD,CAApC,GAA6CA,IAAI,CAACvI,QAAL,EAD3C,CAEF,GAHJ,C,CAKA;;;AACA,MAAMlB,mBAAmB,GAAGZ,IAAI,IAC9BA,IAAI,YAAY/D,kBAAhB,IACA+D,IAAI,YAAY5D,iBADhB,IAEA4D,IAAI,YAAY3D,kBAFhB,IAGA2D,IAAI,YAAY1D,gBAHhB,IAIA0D,IAAI,YAAY9D,qBAJhB,IAKA8D,IAAI,YAAY7D,iBANlB;;AAQA,MAAM8G,QAAQ,GAAG,CAACjD,IAAD,EAAOgD,KAAP,KAAiB;AAChC,MAAIhD,IAAI,YAAYjE,cAApB,EAAoC;AAClC,QAAIiH,KAAK,IAAI,IAAb,EAAmB;AACjB,YAAM,IAAIsH,KAAJ,CAAW,gCAAX,CAAN;AACD;;AACD,WAAOrH,QAAQ,CAACjD,IAAI,CAACuK,MAAN,EAAcvH,KAAd,CAAf;AACD,GALD,MAKO,IAAIhD,IAAI,YAAYhE,WAApB,EAAiC;AACtC,QAAI,CAAC0C,KAAK,CAAC0H,OAAN,CAAcpD,KAAd,CAAL,EAA2B;AACzB,YAAM,IAAIsH,KAAJ,CAAW,6BAAX,CAAN;AACD;;AACD,WAAOtH,KAAK,CAAClE,GAAN,CAAU0L,CAAC,IAAIvH,QAAQ,CAACjD,IAAI,CAACuK,MAAN,EAAcC,CAAd,CAAvB,CAAP;AACD,GALM,MAKA;AACL,WAAOxK,IAAI,CAACyK,UAAL,CAAgBzH,KAAhB,CAAP;AACD;AACF,CAdD;;AAgBA,MAAMjE,wBAAwB,GAAG,CAAC;AAAEzB,EAAAA;AAAF,CAAD,KAAwB;AACvD,QAAMoN,mBAAmB,GAAG,IAAI9L,GAAJ,EAA5B;AACAtB,EAAAA,cAAc,CAACiC,OAAf,CAAuBS,IAAI,IAAI;AAC7B,QACEA,IAAI,YAAY9D,qBAAhB,IACA8D,IAAI,CAACV,YAAL,CAAmB,eAAnB,CAFF,EAGE;AACAoL,MAAAA,mBAAmB,CAAC1D,GAApB,CAAwBhH,IAAI,CAACI,WAAL,EAAxB;AACD;AACF,GAPD;AAQA,QAAMuK,cAAc,GAAG,EAAvB;AACArN,EAAAA,cAAc,CAACiC,OAAf,CAAuBS,IAAI,IAAI;AAC7B,QAAIA,IAAI,YAAY/D,kBAApB,EAAwC;AACtC,YAAMwH,UAAU,GAAGzD,IAAI,CAAC4K,aAAL,EAAnB;;AACA,UACEnH,UAAU,CAACoH,IAAX,CAAgBnH,KAAK,IAAIgH,mBAAmB,CAACpK,GAApB,CAAwBoD,KAAK,CAACjD,IAA9B,CAAzB,KACA,CAACT,IAAI,CAACb,YAAL,CAAmB,MAAnB,CAFH,EAGE;AACAwL,QAAAA,cAAc,CAACf,IAAf,CAAoB5J,IAAI,CAACI,WAAL,EAApB;AACD;AACF;AACF,GAVD;;AAWA,MAAIuK,cAAc,CAACvC,MAAnB,EAA2B;AACzB5L,IAAAA,MAAM,CAACuF,KAAP,CACG,+DAAD,GACG,yDADH,GAEG,0CAFH,GAGG,GAAE4I,cAAc,CAAC7L,GAAf,CAAmBgM,CAAC,IAAK,KAAIA,CAAE,IAA/B,EAAoCC,IAApC,CAA0C,IAA1C,CAA+C,GAJtD;AAMD;AACF,CA9BD","sourcesContent":["const _ = require(`lodash`)\nconst invariant = require(`invariant`)\nconst {\n  isSpecifiedScalarType,\n  isIntrospectionType,\n  defaultFieldResolver,\n  assertValidName,\n  parse,\n  GraphQLNonNull,\n  GraphQLList,\n} = require(`graphql`)\nconst {\n  ObjectTypeComposer,\n  InterfaceTypeComposer,\n  UnionTypeComposer,\n  InputTypeComposer,\n  ScalarTypeComposer,\n  EnumTypeComposer,\n} = require(`graphql-compose`)\n\nconst apiRunner = require(`../utils/api-runner-node`)\nconst report = require(`gatsby-cli/lib/reporter`)\nconst { addNodeInterfaceFields } = require(`./types/node-interface`)\nconst { addInferredType, addInferredTypes } = require(`./infer`)\nconst { findOne, findManyPaginated } = require(`./resolvers`)\nconst {\n  processFieldExtensions,\n  internalExtensionNames,\n} = require(`./extensions`)\nconst { getPagination } = require(`./types/pagination`)\nconst { getSortInput } = require(`./types/sort`)\nconst { getFilterInput } = require(`./types/filter`)\nconst { isGatsbyType, GatsbyGraphQLTypeKind } = require(`./types/type-builders`)\n\nconst buildSchema = async ({\n  schemaComposer,\n  nodeStore,\n  types,\n  typeMapping,\n  fieldExtensions,\n  thirdPartySchemas,\n  typeConflictReporter,\n  parentSpan,\n}) => {\n  await updateSchemaComposer({\n    schemaComposer,\n    nodeStore,\n    types,\n    typeMapping,\n    fieldExtensions,\n    thirdPartySchemas,\n    typeConflictReporter,\n    parentSpan,\n  })\n  // const { printSchema } = require(`graphql`)\n  const schema = schemaComposer.buildSchema()\n  // console.log(printSchema(schema))\n  return schema\n}\n\nconst rebuildSchemaWithSitePage = async ({\n  schemaComposer,\n  nodeStore,\n  typeMapping,\n  fieldExtensions,\n  typeConflictReporter,\n  parentSpan,\n}) => {\n  const typeComposer = addInferredType({\n    schemaComposer,\n    typeComposer: schemaComposer.getOTC(`SitePage`),\n    nodeStore,\n    typeConflictReporter,\n    typeMapping,\n    parentSpan,\n  })\n  await processTypeComposer({\n    schemaComposer,\n    typeComposer,\n    fieldExtensions,\n    nodeStore,\n    parentSpan,\n  })\n  return schemaComposer.buildSchema()\n}\n\nmodule.exports = {\n  buildSchema,\n  rebuildSchemaWithSitePage,\n}\n\nconst updateSchemaComposer = async ({\n  schemaComposer,\n  nodeStore,\n  types,\n  typeMapping,\n  fieldExtensions,\n  thirdPartySchemas,\n  typeConflictReporter,\n  parentSpan,\n}) => {\n  await addTypes({ schemaComposer, parentSpan, types })\n  await addInferredTypes({\n    schemaComposer,\n    nodeStore,\n    typeConflictReporter,\n    typeMapping,\n    parentSpan,\n  })\n  await addSetFieldsOnGraphQLNodeTypeFields({\n    schemaComposer,\n    nodeStore,\n    parentSpan,\n  })\n  await Promise.all(\n    Array.from(new Set(schemaComposer.values())).map(typeComposer =>\n      processTypeComposer({\n        schemaComposer,\n        typeComposer,\n        fieldExtensions,\n        nodeStore,\n        parentSpan,\n      })\n    )\n  )\n  checkQueryableInterfaces({ schemaComposer })\n  await addConvenienceChildrenFields({ schemaComposer, parentSpan })\n  await addThirdPartySchemas({ schemaComposer, thirdPartySchemas, parentSpan })\n  await addCustomResolveFunctions({ schemaComposer, parentSpan })\n}\n\nconst processTypeComposer = async ({\n  schemaComposer,\n  typeComposer,\n  fieldExtensions,\n  nodeStore,\n  parentSpan,\n}) => {\n  if (typeComposer instanceof ObjectTypeComposer) {\n    await processFieldExtensions({\n      schemaComposer,\n      typeComposer,\n      fieldExtensions,\n      parentSpan,\n    })\n    if (typeComposer.hasInterface(`Node`)) {\n      await addNodeInterfaceFields({ schemaComposer, typeComposer, parentSpan })\n      await addImplicitConvenienceChildrenFields({\n        schemaComposer,\n        typeComposer,\n        nodeStore,\n        parentSpan,\n      })\n      await addTypeToRootQuery({ schemaComposer, typeComposer, parentSpan })\n    }\n  } else if (typeComposer instanceof InterfaceTypeComposer) {\n    if (typeComposer.getExtension(`nodeInterface`)) {\n      // We only process field extensions for queryable Node interfaces, so we get\n      // the input args on the root query type, e.g. `formatString` etc. for `dateformat`\n      await processFieldExtensions({\n        schemaComposer,\n        typeComposer,\n        fieldExtensions,\n        parentSpan,\n      })\n      await addTypeToRootQuery({ schemaComposer, typeComposer, parentSpan })\n    }\n  }\n}\n\nconst addTypes = ({ schemaComposer, types, parentSpan }) => {\n  types.forEach(({ typeOrTypeDef, plugin }) => {\n    if (typeof typeOrTypeDef === `string`) {\n      let parsedTypes\n      const createdFrom = `sdl`\n      try {\n        parsedTypes = parseTypeDefs({\n          typeDefs: typeOrTypeDef,\n          plugin,\n          createdFrom,\n          schemaComposer,\n          parentSpan,\n        })\n      } catch (error) {\n        reportParsingError(error)\n        return\n      }\n      parsedTypes.forEach(type => {\n        processAddedType({\n          schemaComposer,\n          type,\n          parentSpan,\n          createdFrom,\n          plugin,\n        })\n      })\n    } else if (isGatsbyType(typeOrTypeDef)) {\n      const type = createTypeComposerFromGatsbyType({\n        schemaComposer,\n        type: typeOrTypeDef,\n        parentSpan,\n      })\n\n      if (type) {\n        const typeName = type.getTypeName()\n        const createdFrom = `typeBuilder`\n        checkIsAllowedTypeName(typeName)\n        if (schemaComposer.has(typeName)) {\n          const typeComposer = schemaComposer.get(typeName)\n          mergeTypes({\n            schemaComposer,\n            typeComposer,\n            type,\n            plugin,\n            createdFrom,\n            parentSpan,\n          })\n        } else {\n          processAddedType({\n            schemaComposer,\n            type,\n            parentSpan,\n            createdFrom,\n            plugin,\n          })\n        }\n      }\n    } else {\n      const typeName = typeOrTypeDef.name\n      const createdFrom = `graphql-js`\n      checkIsAllowedTypeName(typeName)\n      if (schemaComposer.has(typeName)) {\n        const typeComposer = schemaComposer.get(typeName)\n        mergeTypes({\n          schemaComposer,\n          typeComposer,\n          type: typeOrTypeDef,\n          plugin,\n          createdFrom,\n          parentSpan,\n        })\n      } else {\n        processAddedType({\n          schemaComposer,\n          type: typeOrTypeDef,\n          parentSpan,\n          createdFrom,\n          plugin,\n        })\n      }\n    }\n  })\n}\n\nconst mergeTypes = ({\n  schemaComposer,\n  typeComposer,\n  type,\n  plugin,\n  createdFrom,\n  parentSpan,\n}) => {\n  // Only allow user or plugin owning the type to extend already existing type.\n  const typeOwner = typeComposer.getExtension(`plugin`)\n  if (\n    !plugin ||\n    plugin.name === `default-site-plugin` ||\n    plugin.name === typeOwner\n  ) {\n    typeComposer.merge(type)\n    if (isNamedTypeComposer(type)) {\n      typeComposer.extendExtensions(type.getExtensions())\n    }\n    addExtensions({ schemaComposer, typeComposer, plugin, createdFrom })\n    return true\n  } else {\n    report.warn(\n      `Plugin \\`${plugin.name}\\` tried to define the GraphQL type ` +\n        `\\`${typeComposer.getTypeName()}\\`, which has already been defined ` +\n        `by the plugin \\`${typeOwner}\\`.`\n    )\n    return false\n  }\n}\n\nconst processAddedType = ({\n  schemaComposer,\n  type,\n  parentSpan,\n  createdFrom,\n  plugin,\n}) => {\n  const typeName = schemaComposer.addAsComposer(type)\n  const typeComposer = schemaComposer.get(typeName)\n  if (\n    typeComposer instanceof InterfaceTypeComposer ||\n    typeComposer instanceof UnionTypeComposer\n  ) {\n    if (!typeComposer.getResolveType()) {\n      typeComposer.setResolveType(node => node.internal.type)\n    }\n  }\n  schemaComposer.addSchemaMustHaveType(typeComposer)\n\n  addExtensions({ schemaComposer, typeComposer, plugin, createdFrom })\n\n  return typeComposer\n}\n\nconst addExtensions = ({\n  schemaComposer,\n  typeComposer,\n  plugin,\n  createdFrom,\n}) => {\n  typeComposer.setExtension(`createdFrom`, createdFrom)\n  typeComposer.setExtension(`plugin`, plugin ? plugin.name : null)\n\n  if (createdFrom === `sdl`) {\n    const directives = typeComposer.getDirectives()\n    directives.forEach(({ name, args }) => {\n      switch (name) {\n        case `infer`:\n        case `dontInfer`:\n          typeComposer.setExtension(`infer`, name === `infer`)\n          if (args.noDefaultResolvers != null) {\n            typeComposer.setExtension(\n              `addDefaultResolvers`,\n              !args.noDefaultResolvers\n            )\n          }\n          break\n        case `mimeTypes`:\n          typeComposer.setExtension(`mimeTypes`, args)\n          break\n        case `childOf`:\n          typeComposer.setExtension(`childOf`, args)\n          break\n        case `nodeInterface`:\n          if (typeComposer instanceof InterfaceTypeComposer) {\n            if (\n              !typeComposer.hasField(`id`) ||\n              typeComposer.getFieldType(`id`).toString() !== `ID!`\n            ) {\n              report.panic(\n                `Interfaces with the \\`nodeInterface\\` extension must have a field ` +\n                  `\\`id\\` of type \\`ID!\\`. Check the type definition of ` +\n                  `\\`${typeComposer.getTypeName()}\\`.`\n              )\n            }\n            typeComposer.setExtension(`nodeInterface`, true)\n          }\n          break\n        default:\n      }\n    })\n  }\n\n  if (\n    typeComposer instanceof ObjectTypeComposer ||\n    typeComposer instanceof InterfaceTypeComposer\n  ) {\n    typeComposer.getFieldNames().forEach(fieldName => {\n      typeComposer.setFieldExtension(fieldName, `createdFrom`, createdFrom)\n      typeComposer.setFieldExtension(\n        fieldName,\n        `plugin`,\n        plugin ? plugin.name : null\n      )\n\n      if (createdFrom === `sdl`) {\n        const directives = typeComposer.getFieldDirectives(fieldName)\n        directives.forEach(({ name, args }) => {\n          typeComposer.setFieldExtension(fieldName, name, args)\n        })\n      }\n\n      // Validate field extension args. `graphql-compose` already checks the\n      // type of directive args in `parseDirectives`, but we want to check\n      // extensions provided with type builders as well. Also, we warn if an\n      // extension option was provided which does not exist in the field\n      // extension definition.\n      const fieldExtensions = typeComposer.getFieldExtensions(fieldName)\n      const typeName = typeComposer.getTypeName()\n      Object.keys(fieldExtensions)\n        .filter(name => !internalExtensionNames.includes(name))\n        .forEach(name => {\n          const args = fieldExtensions[name]\n          try {\n            const definition = schemaComposer.getDirective(name)\n\n            // Handle `defaultValue` when not provided as directive\n            definition.args.forEach(({ name, defaultValue }) => {\n              if (args[name] === undefined && defaultValue !== undefined) {\n                args[name] = defaultValue\n              }\n            })\n\n            Object.keys(args).forEach(arg => {\n              const argumentDef = definition.args.find(\n                ({ name }) => name === arg\n              )\n              if (!argumentDef) {\n                report.error(\n                  `Field extension \\`${name}\\` on \\`${typeName}.${fieldName}\\` ` +\n                    `has invalid argument \\`${arg}\\`.`\n                )\n                return\n              }\n              const value = args[arg]\n              try {\n                validate(argumentDef.type, value)\n              } catch (error) {\n                report.error(\n                  `Field extension \\`${name}\\` on \\`${typeName}.${fieldName}\\` ` +\n                    `has argument \\`${arg}\\` with invalid value \"${value}\". ` +\n                    error.message\n                )\n              }\n            })\n          } catch (error) {\n            report.error(\n              `Field extension \\`${name}\\` on \\`${typeName}.${fieldName}\\` ` +\n                `is not available.`\n            )\n          }\n        })\n    })\n  }\n\n  if (typeComposer.hasExtension(`addDefaultResolvers`)) {\n    report.warn(\n      `Deprecation warning - \"noDefaultResolvers\" is deprecated. In Gatsby 3, ` +\n        `defined fields won't get resolvers, unless explicitly added with a ` +\n        `directive/extension.`\n    )\n  }\n\n  return typeComposer\n}\n\nconst checkIsAllowedTypeName = name => {\n  invariant(\n    name !== `Node`,\n    `The GraphQL type \\`Node\\` is reserved for internal use.`\n  )\n  invariant(\n    !name.endsWith(`FilterInput`) && !name.endsWith(`SortInput`),\n    `GraphQL type names ending with \"FilterInput\" or \"SortInput\" are ` +\n      `reserved for internal use. Please rename \\`${name}\\`.`\n  )\n  invariant(\n    ![`Boolean`, `Date`, `Float`, `ID`, `Int`, `JSON`, `String`].includes(name),\n    `The GraphQL type \\`${name}\\` is reserved for internal use by ` +\n      `built-in scalar types.`\n  )\n  assertValidName(name)\n}\n\nconst createTypeComposerFromGatsbyType = ({\n  schemaComposer,\n  type,\n  parentSpan,\n}) => {\n  switch (type.kind) {\n    case GatsbyGraphQLTypeKind.OBJECT: {\n      return ObjectTypeComposer.createTemp(\n        {\n          ...type.config,\n          interfaces: () => {\n            if (type.config.interfaces) {\n              return type.config.interfaces.map(iface => {\n                if (typeof iface === `string`) {\n                  return schemaComposer.getIFTC(iface).getType()\n                } else {\n                  return iface\n                }\n              })\n            } else {\n              return []\n            }\n          },\n        },\n        schemaComposer\n      )\n    }\n    case GatsbyGraphQLTypeKind.INPUT_OBJECT: {\n      return InputTypeComposer.createTemp(type.config, schemaComposer)\n    }\n    case GatsbyGraphQLTypeKind.UNION: {\n      return UnionTypeComposer.createTemp(\n        {\n          ...type.config,\n          types: () => {\n            if (type.config.types) {\n              return type.config.types.map(typeName =>\n                schemaComposer.getOTC(typeName).getType()\n              )\n            } else {\n              return []\n            }\n          },\n        },\n        schemaComposer\n      )\n    }\n    case GatsbyGraphQLTypeKind.INTERFACE: {\n      return InterfaceTypeComposer.createTemp(type.config, schemaComposer)\n    }\n    case GatsbyGraphQLTypeKind.ENUM: {\n      return EnumTypeComposer.createTemp(type.config, schemaComposer)\n    }\n    case GatsbyGraphQLTypeKind.SCALAR: {\n      return ScalarTypeComposer.createTemp(type.config, schemaComposer)\n    }\n    default: {\n      report.warn(`Illegal type definition: ${JSON.stringify(type.config)}`)\n      return null\n    }\n  }\n}\n\nconst addSetFieldsOnGraphQLNodeTypeFields = ({\n  schemaComposer,\n  nodeStore,\n  parentSpan,\n}) =>\n  Promise.all(\n    Array.from(schemaComposer.values()).map(async tc => {\n      if (tc instanceof ObjectTypeComposer && tc.hasInterface(`Node`)) {\n        const typeName = tc.getTypeName()\n        const result = await apiRunner(`setFieldsOnGraphQLNodeType`, {\n          type: {\n            name: typeName,\n            nodes: nodeStore.getNodesByType(typeName),\n          },\n          traceId: `initial-setFieldsOnGraphQLNodeType`,\n          parentSpan,\n        })\n        if (result) {\n          // NOTE: `setFieldsOnGraphQLNodeType` only allows setting\n          // nested fields with a path as property name, i.e.\n          // `{ 'frontmatter.published': 'Boolean' }`, but not in the form\n          // `{ frontmatter: { published: 'Boolean' }}`\n          result.forEach(fields => tc.addNestedFields(fields))\n        }\n      }\n    })\n  )\n\nconst addThirdPartySchemas = ({\n  schemaComposer,\n  thirdPartySchemas,\n  parentSpan,\n}) => {\n  thirdPartySchemas.forEach(schema => {\n    const schemaQueryType = schema.getQueryType()\n    const queryTC = schemaComposer.createTempTC(schemaQueryType)\n    processThirdPartyTypeFields({ typeComposer: queryTC, schemaQueryType })\n    schemaComposer.Query.addFields(queryTC.getFields())\n\n    // Explicitly add the third-party schema's types, so they can be targeted\n    // in `createResolvers` API.\n    const types = schema.getTypeMap()\n    Object.keys(types).forEach(typeName => {\n      const type = types[typeName]\n      if (\n        type !== schemaQueryType &&\n        !isSpecifiedScalarType(type) &&\n        !isIntrospectionType(type) &&\n        type.name !== `Date` &&\n        type.name !== `JSON`\n      ) {\n        const typeComposer = schemaComposer.createTC(type)\n        if (\n          typeComposer instanceof ObjectTypeComposer ||\n          typeComposer instanceof InterfaceTypeComposer\n        ) {\n          processThirdPartyTypeFields({ typeComposer, schemaQueryType })\n        }\n        typeComposer.setExtension(`createdFrom`, `thirdPartySchema`)\n        schemaComposer.addSchemaMustHaveType(typeComposer)\n      }\n    })\n  })\n}\n\nconst processThirdPartyTypeFields = ({ typeComposer, schemaQueryType }) => {\n  // Fix for types that refer to Query. Thanks Relay Classic!\n  typeComposer.getFieldNames().forEach(fieldName => {\n    const field = typeComposer.getField(fieldName)\n    const fieldType = field.type.toString()\n    if (fieldType.replace(/[[\\]!]/g, ``) === schemaQueryType.name) {\n      typeComposer.extendField(fieldName, {\n        type: fieldType.replace(schemaQueryType.name, `Query`),\n      })\n    }\n  })\n}\n\nconst addCustomResolveFunctions = async ({ schemaComposer, parentSpan }) => {\n  const intermediateSchema = schemaComposer.buildSchema()\n  const createResolvers = resolvers => {\n    Object.keys(resolvers).forEach(typeName => {\n      const fields = resolvers[typeName]\n      if (schemaComposer.has(typeName)) {\n        const tc = schemaComposer.getOTC(typeName)\n        Object.keys(fields).forEach(fieldName => {\n          const fieldConfig = fields[fieldName]\n          if (tc.hasField(fieldName)) {\n            const originalFieldConfig = tc.getFieldConfig(fieldName)\n            const originalTypeName = originalFieldConfig.type.toString()\n            const originalResolver = originalFieldConfig.resolve\n            let fieldTypeName\n            if (fieldConfig.type) {\n              fieldTypeName = Array.isArray(fieldConfig.type)\n                ? stringifyArray(fieldConfig.type)\n                : fieldConfig.type.toString()\n            }\n\n            if (\n              !fieldTypeName ||\n              fieldTypeName.replace(/!/g, ``) ===\n                originalTypeName.replace(/!/g, ``) ||\n              tc.getExtension(`createdFrom`) === `thirdPartySchema`\n            ) {\n              const newConfig = {}\n              if (fieldConfig.type) {\n                newConfig.type = fieldConfig.type\n              }\n              if (fieldConfig.args) {\n                newConfig.args = fieldConfig.args\n              }\n              if (fieldConfig.resolve) {\n                newConfig.resolve = (source, args, context, info) =>\n                  fieldConfig.resolve(source, args, context, {\n                    ...info,\n                    originalResolver: originalResolver || defaultFieldResolver,\n                  })\n              }\n              tc.extendField(fieldName, newConfig)\n            } else if (fieldTypeName) {\n              report.warn(\n                `\\`createResolvers\\` passed resolvers for field ` +\n                  `\\`${typeName}.${fieldName}\\` with type \\`${fieldTypeName}\\`. ` +\n                  `Such a field with type \\`${originalTypeName}\\` already exists ` +\n                  `on the type. Use \\`createTypes\\` to override type fields.`\n              )\n            }\n          } else {\n            tc.addFields({ [fieldName]: fieldConfig })\n          }\n        })\n      } else {\n        report.warn(\n          `\\`createResolvers\\` passed resolvers for type \\`${typeName}\\` that ` +\n            `doesn't exist in the schema. Use \\`createTypes\\` to add the type ` +\n            `before adding resolvers.`\n        )\n      }\n    })\n  }\n  await apiRunner(`createResolvers`, {\n    intermediateSchema,\n    createResolvers,\n    traceId: `initial-createResolvers`,\n    parentSpan,\n  })\n}\n\nconst addConvenienceChildrenFields = ({ schemaComposer }) => {\n  const parentTypesToChildren = new Map()\n  const mimeTypesToChildren = new Map()\n  const typesHandlingMimeTypes = new Map()\n\n  schemaComposer.forEach(type => {\n    if (\n      (type instanceof ObjectTypeComposer ||\n        type instanceof InterfaceTypeComposer) &&\n      type.hasExtension(`mimeTypes`)\n    ) {\n      const { types } = type.getExtension(`mimeTypes`)\n      new Set(types).forEach(mimeType => {\n        if (!typesHandlingMimeTypes.has(mimeType)) {\n          typesHandlingMimeTypes.set(mimeType, new Set())\n        }\n        typesHandlingMimeTypes.get(mimeType).add(type)\n      })\n    }\n\n    if (\n      (type instanceof ObjectTypeComposer ||\n        type instanceof InterfaceTypeComposer) &&\n      type.hasExtension(`childOf`)\n    ) {\n      if (type instanceof ObjectTypeComposer && !type.hasInterface(`Node`)) {\n        report.error(\n          `The \\`childOf\\` extension can only be used on types that implement the \\`Node\\` interface.\\n` +\n            `Check the type definition of \\`${type.getTypeName()}\\`.`\n        )\n        return\n      }\n      if (\n        type instanceof InterfaceTypeComposer &&\n        !type.hasExtension(`nodeInterface`)\n      ) {\n        report.error(\n          `The \\`childOf\\` extension can only be used on interface types that ` +\n            `have the \\`@nodeInterface\\` extension.\\n` +\n            `Check the type definition of \\`${type.getTypeName()}\\`.`\n        )\n        return\n      }\n\n      const { types, mimeTypes, many } = type.getExtension(`childOf`)\n      new Set(types).forEach(parentType => {\n        if (!parentTypesToChildren.has(parentType)) {\n          parentTypesToChildren.set(parentType, new Map())\n        }\n        parentTypesToChildren.get(parentType).set(type, many)\n      })\n      new Set(mimeTypes).forEach(mimeType => {\n        if (!mimeTypesToChildren.has(mimeType)) {\n          mimeTypesToChildren.set(mimeType, new Map())\n        }\n        mimeTypesToChildren.get(mimeType).set(type, many)\n      })\n    }\n  })\n\n  parentTypesToChildren.forEach((children, parent) => {\n    const typeComposer = schemaComposer.getAnyTC(parent)\n    if (\n      typeComposer instanceof InterfaceTypeComposer &&\n      !typeComposer.hasExtension(`nodeInterface`)\n    ) {\n      report.error(\n        `With the \\`childOf\\` extension, children fields can only be added to ` +\n          `interfaces which have the \\`@nodeInterface\\` extension.\\n` +\n          `Check the type definition of \\`${typeComposer.getTypeName()}\\`.`\n      )\n      return\n    }\n    children.forEach((many, child) => {\n      if (many) {\n        typeComposer.addFields(createChildrenField(child.getTypeName()))\n      } else {\n        typeComposer.addFields(createChildField(child.getTypeName()))\n      }\n    })\n  })\n\n  mimeTypesToChildren.forEach((children, mimeType) => {\n    const parentTypes = typesHandlingMimeTypes.get(mimeType)\n    if (parentTypes) {\n      parentTypes.forEach(parent => {\n        const typeComposer = schemaComposer.getAnyTC(parent)\n        if (\n          typeComposer instanceof InterfaceTypeComposer &&\n          !typeComposer.hasExtension(`nodeInterface`)\n        ) {\n          report.error(\n            `With the \\`childOf\\` extension, children fields can only be added to ` +\n              `interfaces which have the \\`@nodeInterface\\` extension.\\n` +\n              `Check the type definition of \\`${typeComposer.getTypeName()}\\`.`\n          )\n          return\n        }\n        children.forEach((many, child) => {\n          if (many) {\n            typeComposer.addFields(createChildrenField(child.getTypeName()))\n          } else {\n            typeComposer.addFields(createChildField(child.getTypeName()))\n          }\n        })\n      })\n    }\n  })\n}\n\nconst addImplicitConvenienceChildrenFields = ({\n  schemaComposer,\n  typeComposer,\n  nodeStore,\n}) => {\n  const shouldInfer = typeComposer.getExtension(`infer`)\n  // In Gatsby v3, when `@dontInfer` is set, children fields will not be\n  // created for parent-child relations set by plugins with\n  // `createParentChildLink`. With `@dontInfer`, only parent-child\n  // relations explicitly set with the `childOf` extension will be added.\n  // if (shouldInfer === false) return\n\n  const nodes = nodeStore.getNodesByType(typeComposer.getTypeName())\n\n  const childNodesByType = groupChildNodesByType({ nodeStore, nodes })\n\n  Object.keys(childNodesByType).forEach(typeName => {\n    const typeChildren = childNodesByType[typeName]\n    const maxChildCount = _.maxBy(\n      _.values(_.groupBy(typeChildren, c => c.parent)),\n      g => g.length\n    ).length\n\n    // Adding children fields to types with the `@dontInfer` extension is deprecated\n    if (shouldInfer === false) {\n      const fieldName = _.camelCase(\n        `${maxChildCount > 1 ? `children` : `child`} ${typeName}`\n      )\n      if (!typeComposer.hasField(fieldName)) {\n        report.warn(\n          `On types with the \\`@dontInfer\\` directive, or with the \\`infer\\` ` +\n            `extension set to \\`false\\`, automatically adding fields for ` +\n            `children types is deprecated.\\n` +\n            `In Gatsby v3, only children fields explicitly set with the ` +\n            `\\`childOf\\` extension will be added.\\n` +\n            `For example, in Gatsby v3, \\`${typeComposer.getTypeName()}\\` will ` +\n            `not get a \\`${fieldName}\\` field.`\n        )\n      }\n    }\n\n    if (maxChildCount > 1) {\n      typeComposer.addFields(createChildrenField(typeName))\n    } else {\n      typeComposer.addFields(createChildField(typeName))\n    }\n  })\n}\n\nconst createChildrenField = typeName => {\n  return {\n    [_.camelCase(`children ${typeName}`)]: {\n      type: () => [typeName],\n      resolve(source, args, context) {\n        const { path } = context\n        return context.nodeModel.getNodesByIds(\n          { ids: source.children, type: typeName },\n          { path }\n        )\n      },\n    },\n  }\n}\n\nconst createChildField = typeName => {\n  return {\n    [_.camelCase(`child ${typeName}`)]: {\n      type: () => typeName,\n      async resolve(source, args, context) {\n        const { path } = context\n        const result = await context.nodeModel.getNodesByIds(\n          { ids: source.children, type: typeName },\n          { path }\n        )\n        if (result && result.length > 0) {\n          return result[0]\n        } else {\n          return null\n        }\n      },\n    },\n  }\n}\n\nconst groupChildNodesByType = ({ nodeStore, nodes }) =>\n  _(nodes)\n    .flatMap(node => (node.children || []).map(nodeStore.getNode))\n    .groupBy(node => (node.internal ? node.internal.type : undefined))\n    .value()\n\nconst addTypeToRootQuery = ({ schemaComposer, typeComposer }) => {\n  // TODO: We should have an abstraction for keeping and clearing\n  // related TypeComposers and InputTypeComposers.\n  // Also see the comment on the skipped test in `rebuild-schema`.\n  typeComposer.removeInputTypeComposer()\n\n  const sortInputTC = getSortInput({\n    schemaComposer,\n    typeComposer,\n  })\n  const filterInputTC = getFilterInput({\n    schemaComposer,\n    typeComposer,\n  })\n  const paginationTC = getPagination({\n    schemaComposer,\n    typeComposer,\n  })\n\n  const typeName = typeComposer.getTypeName()\n  // not strictly correctly, result is `npmPackage` and `allNpmPackage` from type `NPMPackage`\n  const queryName = _.camelCase(typeName)\n  const queryNamePlural = _.camelCase(`all ${typeName}`)\n\n  schemaComposer.Query.addFields({\n    [queryName]: {\n      type: typeComposer,\n      args: {\n        ...filterInputTC.getFields(),\n      },\n      resolve: findOne(typeName),\n    },\n    [queryNamePlural]: {\n      type: paginationTC,\n      args: {\n        filter: filterInputTC,\n        sort: sortInputTC,\n        skip: `Int`,\n        limit: `Int`,\n      },\n      resolve: findManyPaginated(typeName),\n    },\n  })\n}\n\nconst parseTypes = ({\n  doc,\n  plugin,\n  createdFrom,\n  schemaComposer,\n  parentSpan,\n}) => {\n  const types = []\n  doc.definitions.forEach(def => {\n    const name = def.name.value\n    checkIsAllowedTypeName(name)\n\n    if (schemaComposer.has(name)) {\n      // We don't check if ast.kind matches composer type, but rely\n      // that this will throw when something is wrong and get\n      // reported by `reportParsingError`.\n\n      // Keep the original type composer around\n      const typeComposer = schemaComposer.get(name)\n\n      // After this, the parsed type composer will be registered as the composer\n      // handling the type name\n      const parsedType = schemaComposer.typeMapper.makeSchemaDef(def)\n\n      // Merge the parsed type with the original\n      mergeTypes({\n        schemaComposer,\n        typeComposer,\n        type: parsedType,\n        plugin,\n        createdFrom,\n        parentSpan,\n      })\n\n      // Set the original type composer (with the merged fields added)\n      // as the correct composer for the type name\n      schemaComposer.typeMapper.set(typeComposer.getTypeName(), typeComposer)\n    } else {\n      const parsedType = schemaComposer.typeMapper.makeSchemaDef(def)\n      types.push(parsedType)\n    }\n  })\n  return types\n}\n\nconst parseTypeDefs = ({\n  typeDefs,\n  plugin,\n  createdFrom,\n  schemaComposer,\n  parentSpan,\n}) => {\n  const doc = parse(typeDefs)\n  return parseTypes({ doc, plugin, createdFrom, schemaComposer, parentSpan })\n}\n\nconst reportParsingError = error => {\n  const { message, source, locations } = error\n\n  if (source && locations && locations.length) {\n    const { codeFrameColumns } = require(`@babel/code-frame`)\n\n    const frame = codeFrameColumns(\n      source.body,\n      { start: locations[0] },\n      { linesAbove: 5, linesBelow: 5 }\n    )\n    report.panic(\n      `Encountered an error parsing the provided GraphQL type definitions:\\n` +\n        message +\n        `\\n\\n` +\n        frame +\n        `\\n`\n    )\n  } else {\n    throw error\n  }\n}\n\nconst stringifyArray = arr =>\n  `[${arr.map(item =>\n    Array.isArray(item) ? stringifyArray(item) : item.toString()\n  )}]`\n\n// TODO: Import this directly from graphql-compose once we update to v7\nconst isNamedTypeComposer = type =>\n  type instanceof ObjectTypeComposer ||\n  type instanceof InputTypeComposer ||\n  type instanceof ScalarTypeComposer ||\n  type instanceof EnumTypeComposer ||\n  type instanceof InterfaceTypeComposer ||\n  type instanceof UnionTypeComposer\n\nconst validate = (type, value) => {\n  if (type instanceof GraphQLNonNull) {\n    if (value == null) {\n      throw new Error(`Expected non-null field value.`)\n    }\n    return validate(type.ofType, value)\n  } else if (type instanceof GraphQLList) {\n    if (!Array.isArray(value)) {\n      throw new Error(`Expected array field value.`)\n    }\n    return value.map(v => validate(type.ofType, v))\n  } else {\n    return type.parseValue(value)\n  }\n}\n\nconst checkQueryableInterfaces = ({ schemaComposer }) => {\n  const queryableInterfaces = new Set()\n  schemaComposer.forEach(type => {\n    if (\n      type instanceof InterfaceTypeComposer &&\n      type.getExtension(`nodeInterface`)\n    ) {\n      queryableInterfaces.add(type.getTypeName())\n    }\n  })\n  const incorrectTypes = []\n  schemaComposer.forEach(type => {\n    if (type instanceof ObjectTypeComposer) {\n      const interfaces = type.getInterfaces()\n      if (\n        interfaces.some(iface => queryableInterfaces.has(iface.name)) &&\n        !type.hasInterface(`Node`)\n      ) {\n        incorrectTypes.push(type.getTypeName())\n      }\n    }\n  })\n  if (incorrectTypes.length) {\n    report.panic(\n      `Interfaces with the \\`nodeInterface\\` extension must only be ` +\n        `implemented by types which also implement the \\`Node\\` ` +\n        `interface. Check the type definition of ` +\n        `${incorrectTypes.map(t => `\\`${t}\\``).join(`, `)}.`\n    )\n  }\n}\n"],"file":"schema.js"}